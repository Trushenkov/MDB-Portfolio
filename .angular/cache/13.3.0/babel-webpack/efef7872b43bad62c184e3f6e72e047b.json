{"ast":null,"code":"import { EventEmitter, Directive, ElementRef, Renderer2, HostBinding, Output, Input, NgModule, forwardRef, HostListener, ContentChildren, Component, ChangeDetectionStrategy, ChangeDetectorRef, ViewChild, ContentChild, Inject, TemplateRef, Injector, Injectable, ComponentFactoryResolver, ViewContainerRef, NgZone, InjectionToken } from '@angular/core';\nimport { fromEvent, Subject, from } from 'rxjs';\nimport { take, startWith, switchMap, takeUntil, first, filter, distinctUntilChanged } from 'rxjs/operators';\nimport { CommonModule, DOCUMENT } from '@angular/common';\nimport { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';\nimport { OverlayConfig, Overlay, OverlayPositionBuilder, OverlayModule } from '@angular/cdk/overlay';\nimport { ComponentPortal, CdkPortalOutlet, TemplatePortal, PortalModule } from '@angular/cdk/portal';\nimport { trigger, state, style, transition, animate } from '@angular/animations';\nimport { ContentObserver } from '@angular/cdk/observers';\nimport { ConfigurableFocusTrapFactory } from '@angular/cdk/a11y';\nimport { BreakpointObserver } from '@angular/cdk/layout';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nimport * as ɵngcc2 from '@angular/cdk/overlay';\nimport * as ɵngcc3 from '@angular/cdk/observers';\nimport * as ɵngcc4 from '@angular/cdk/a11y';\nimport * as ɵngcc5 from '@angular/cdk/portal';\nimport * as ɵngcc6 from '@angular/cdk/layout';\nimport * as ɵngcc7 from '@angular/forms';\n\nfunction MdbTooltipComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 2);\n    ɵngcc0.ɵɵlistener(\"@fade.done\", function MdbTooltipComponent_div_0_Template_div_animation_fade_done_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      const ctx_r2 = ɵngcc0.ɵɵnextContext();\n      return ctx_r2.onAnimationEnd($event);\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"@fade\", ctx_r0.animationState)(\"@.disabled\", !ctx_r0.animation)(\"innerHTML\", ctx_r0.title, ɵngcc0.ɵɵsanitizeHtml);\n  }\n}\n\nfunction MdbTooltipComponent_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\", 3);\n    ɵngcc0.ɵɵlistener(\"@fade.done\", function MdbTooltipComponent_div_1_Template_div_animation_fade_done_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r5);\n      const ctx_r4 = ɵngcc0.ɵɵnextContext();\n      return ctx_r4.onAnimationEnd($event);\n    });\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"@fade\", ctx_r1.animationState)(\"@.disabled\", !ctx_r1.animation);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r1.title, \"\\n\");\n  }\n}\n\nfunction MdbPopoverComponent_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 4);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r0.title, \" \");\n  }\n}\n\nfunction MdbPopoverComponent_div_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"div\", 5);\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"innerHTML\", ctx_r1.content, ɵngcc0.ɵɵsanitizeHtml);\n  }\n}\n\nfunction MdbPopoverComponent_div_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 6);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", ctx_r2.content, \" \");\n  }\n}\n\nconst _c0 = [\"notchLeading\"];\nconst _c1 = [\"notchMiddle\"];\nconst _c2 = [\"*\"];\nconst _c3 = [\"dialog\"];\n\nfunction MdbModalContainerComponent_ng_template_3_Template(rf, ctx) {}\n\nconst _c4 = [\"dropdownTemplate\"];\nconst _c5 = [\"mdbDropdown\", \"\"];\n\nfunction MdbDropdownDirective_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"div\");\n    ɵngcc0.ɵɵlistener(\"@fade.done\", function MdbDropdownDirective_ng_template_2_Template_div_animation_fade_done_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r3);\n      const ctx_r2 = ɵngcc0.ɵɵnextContext();\n      return ctx_r2.onAnimationEnd($event);\n    });\n    ɵngcc0.ɵɵprojection(1, 2);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"@fade\", ctx_r1._animationState)(\"@.disabled\", !ctx_r1.animation);\n  }\n}\n\nconst _c6 = [\"*\", [[\"\", 8, \"dropdown-toggle\"]], [[\"\", 8, \"dropdown-menu\"]]];\nconst _c7 = [\"*\", \".dropdown-toggle\", \".dropdown-menu\"];\nconst _c8 = [\"mdbScrollspy\", \"\"];\nconst _c9 = [\"input\"];\nconst _c10 = [\"thumb\"];\nconst _c11 = [\"thumbValue\"];\n\nconst _c12 = function (a0) {\n  return {\n    \"thumb-active\": a0\n  };\n};\n\nfunction MdbTabComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵprojection(0);\n  }\n}\n\nfunction MdbTabsComponent_li_1_ng_template_2_ng_template_0_Template(rf, ctx) {}\n\nfunction MdbTabsComponent_li_1_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtemplate(0, MdbTabsComponent_li_1_ng_template_2_ng_template_0_Template, 0, 0, \"ng-template\", 7);\n  }\n\n  if (rf & 2) {\n    const tab_r2 = ɵngcc0.ɵɵnextContext().$implicit;\n    ɵngcc0.ɵɵproperty(\"cdkPortalOutlet\", tab_r2.titleContent);\n  }\n}\n\nfunction MdbTabsComponent_li_1_ng_template_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵtext(0);\n  }\n\n  if (rf & 2) {\n    const tab_r2 = ɵngcc0.ɵɵnextContext().$implicit;\n    ɵngcc0.ɵɵtextInterpolate(tab_r2.title);\n  }\n}\n\nfunction MdbTabsComponent_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r10 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"li\", 4);\n    ɵngcc0.ɵɵlistener(\"click\", function MdbTabsComponent_li_1_Template_li_click_0_listener() {\n      const restoredCtx = ɵngcc0.ɵɵrestoreView(_r10);\n      const i_r3 = restoredCtx.index;\n      const ctx_r9 = ɵngcc0.ɵɵnextContext();\n      return ctx_r9.setActiveTab(i_r3);\n    });\n    ɵngcc0.ɵɵelementStart(1, \"a\", 5);\n    ɵngcc0.ɵɵtemplate(2, MdbTabsComponent_li_1_ng_template_2_Template, 1, 1, \"ng-template\", 6);\n    ɵngcc0.ɵɵtemplate(3, MdbTabsComponent_li_1_ng_template_3_Template, 1, 1, \"ng-template\", 6);\n    ɵngcc0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const tab_r2 = ctx.$implicit;\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵclassProp(\"active\", tab_r2.active)(\"disabled\", tab_r2.disabled);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", tab_r2.titleContent);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !tab_r2.titleContent);\n  }\n}\n\nfunction MdbTabsComponent_ng_container_3_ng_template_2_Template(rf, ctx) {}\n\nconst _c13 = function (a0, a1) {\n  return {\n    show: a0,\n    active: a1\n  };\n};\n\nfunction MdbTabsComponent_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵelementStart(1, \"div\", 8);\n    ɵngcc0.ɵɵtemplate(2, MdbTabsComponent_ng_container_3_ng_template_2_Template, 0, 0, \"ng-template\", 9);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const tab_r11 = ctx.$implicit;\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction2(2, _c13, tab_r11.active, tab_r11.active));\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"tab\", tab_r11);\n  }\n}\n\nconst _c14 = function (a0, a1, a2, a3, a4, a5, a6) {\n  return {\n    \"nav-pills\": a0,\n    \"nav-tabs\": a1,\n    \"nav-fill\": a2,\n    \"nav-justified\": a3,\n    \"flex-column\": a4,\n    \"col-3\": a5,\n    \"text-center\": a6\n  };\n};\n\nconst _c15 = function (a0) {\n  return {\n    \"col-9\": a0\n  };\n};\n\nfunction MdbCarouselComponent_div_1_button_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"button\", 7);\n    ɵngcc0.ɵɵlistener(\"click\", function MdbCarouselComponent_div_1_button_1_Template_button_click_0_listener() {\n      const restoredCtx = ɵngcc0.ɵɵrestoreView(_r7);\n      const i_r5 = restoredCtx.index;\n      const ctx_r6 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r6.to(i_r5);\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const i_r5 = ctx.index;\n    const ctx_r3 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵclassProp(\"active\", i_r5 === ctx_r3.activeSlide);\n    ɵngcc0.ɵɵattribute(\"aria-current\", i_r5 === ctx_r3.activeSlide);\n  }\n}\n\nfunction MdbCarouselComponent_div_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"div\", 5);\n    ɵngcc0.ɵɵtemplate(1, MdbCarouselComponent_div_1_button_1_Template, 1, 3, \"button\", 6);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r0.items);\n  }\n}\n\nfunction MdbCarouselComponent_button_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"button\", 8);\n    ɵngcc0.ɵɵlistener(\"click\", function MdbCarouselComponent_button_4_Template_button_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r9);\n      const ctx_r8 = ɵngcc0.ɵɵnextContext();\n      return ctx_r8.prev();\n    });\n    ɵngcc0.ɵɵelement(1, \"span\", 9);\n    ɵngcc0.ɵɵelementStart(2, \"span\", 10);\n    ɵngcc0.ɵɵtext(3, \"Previous\");\n    ɵngcc0.ɵɵelementEnd()();\n  }\n}\n\nfunction MdbCarouselComponent_button_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r11 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"button\", 11);\n    ɵngcc0.ɵɵlistener(\"click\", function MdbCarouselComponent_button_5_Template_button_click_0_listener() {\n      ɵngcc0.ɵɵrestoreView(_r11);\n      const ctx_r10 = ɵngcc0.ɵɵnextContext();\n      return ctx_r10.next();\n    });\n    ɵngcc0.ɵɵelement(1, \"span\", 12);\n    ɵngcc0.ɵɵelementStart(2, \"span\", 10);\n    ɵngcc0.ɵɵtext(3, \"Next\");\n    ɵngcc0.ɵɵelementEnd()();\n  }\n}\n\nconst TRANSITION_TIME = 350; // tslint:disable-next-line: component-class-suffix\n\nlet MdbCollapseDirective = /*#__PURE__*/(() => {\n  class MdbCollapseDirective {\n    constructor(_elementRef, _renderer) {\n      this._elementRef = _elementRef;\n      this._renderer = _renderer;\n      this.collapseClass = true;\n      this.collapseShow = new EventEmitter();\n      this.collapseShown = new EventEmitter();\n      this.collapseHide = new EventEmitter();\n      this.collapseHidden = new EventEmitter();\n      this._collapsed = true;\n      this._isTransitioning = false;\n    }\n\n    set collapsed(collapsed) {\n      if (collapsed !== this._collapsed) {\n        collapsed ? this.hide() : this.show();\n        this._collapsed = collapsed;\n      }\n    }\n\n    get collapsed() {\n      return this._collapsed;\n    }\n\n    get host() {\n      return this._elementRef.nativeElement;\n    }\n\n    show() {\n      if (this._isTransitioning || !this.collapsed) {\n        return;\n      }\n\n      this.collapseShow.emit(this);\n\n      this._renderer.removeClass(this.host, 'collapse');\n\n      this._renderer.addClass(this.host, 'collapsing');\n\n      this._renderer.setStyle(this.host, 'height', '0px');\n\n      this._isTransitioning = true;\n      const scrollHeight = this.host.scrollHeight;\n      fromEvent(this.host, 'transitionend').pipe(take(1)).subscribe(() => {\n        this._isTransitioning = false;\n        this.collapsed = false;\n\n        this._renderer.removeClass(this.host, 'collapsing');\n\n        this._renderer.addClass(this.host, 'collapse');\n\n        this._renderer.addClass(this.host, 'show');\n\n        this._renderer.removeStyle(this.host, 'height');\n\n        this.collapseShown.emit(this);\n      });\n\n      this._emulateTransitionEnd(this.host, TRANSITION_TIME);\n\n      this._renderer.setStyle(this.host, 'height', `${scrollHeight}px`);\n    }\n\n    hide() {\n      if (this._isTransitioning || this.collapsed) {\n        return;\n      }\n\n      this.collapseHide.emit(this);\n      const hostHeight = this.host.getBoundingClientRect().height;\n\n      this._renderer.setStyle(this.host, 'height', `${hostHeight}px`);\n\n      this._reflow(this.host);\n\n      this._renderer.addClass(this.host, 'collapsing');\n\n      this._renderer.removeClass(this.host, 'collapse');\n\n      this._renderer.removeClass(this.host, 'show');\n\n      this._isTransitioning = true;\n      fromEvent(this.host, 'transitionend').pipe(take(1)).subscribe(() => {\n        this._renderer.removeClass(this.host, 'collapsing');\n\n        this._renderer.addClass(this.host, 'collapse');\n\n        this._isTransitioning = false;\n        this.collapsed = true;\n        this.collapseHidden.emit(this);\n      });\n\n      this._renderer.removeStyle(this.host, 'height');\n\n      this._emulateTransitionEnd(this.host, TRANSITION_TIME);\n    }\n\n    toggle() {\n      this.collapsed = !this.collapsed;\n      this.collapsed ? this.hide() : this.show();\n    }\n\n    _reflow(element) {\n      return element.offsetHeight;\n    }\n\n    _emulateTransitionEnd(element, duration) {\n      let eventEmitted = false;\n      const durationPadding = 5;\n      const emulatedDuration = duration + durationPadding;\n      fromEvent(element, 'transitionend').pipe(take(1)).subscribe(() => {\n        eventEmitted = true;\n      });\n      setTimeout(() => {\n        if (!eventEmitted) {\n          element.dispatchEvent(new Event('transitionend'));\n        }\n      }, emulatedDuration);\n    }\n\n  }\n\n  MdbCollapseDirective.ɵfac = function MdbCollapseDirective_Factory(t) {\n    return new (t || MdbCollapseDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  MdbCollapseDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbCollapseDirective,\n    selectors: [[\"\", \"mdbCollapse\", \"\"]],\n    hostVars: 2,\n    hostBindings: function MdbCollapseDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"collapse\", ctx.collapseClass);\n      }\n    },\n    inputs: {\n      collapsed: \"collapsed\"\n    },\n    outputs: {\n      collapseShow: \"collapseShow\",\n      collapseShown: \"collapseShown\",\n      collapseHide: \"collapseHide\",\n      collapseHidden: \"collapseHidden\"\n    },\n    exportAs: [\"mdbCollapse\"]\n  });\n  return MdbCollapseDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbCollapseModule = /*#__PURE__*/(() => {\n  class MdbCollapseModule {}\n\n  MdbCollapseModule.ɵfac = function MdbCollapseModule_Factory(t) {\n    return new (t || MdbCollapseModule)();\n  };\n\n  MdbCollapseModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdbCollapseModule\n  });\n  MdbCollapseModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return MdbCollapseModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbCollapseModule, {\n    declarations: [MdbCollapseDirective],\n    exports: [MdbCollapseDirective]\n  });\n})();\n\nconst MDB_CHECKBOX_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  // tslint:disable-next-line: no-use-before-declare\n  useExisting: forwardRef(() => MdbCheckboxDirective),\n  multi: true\n};\n\nclass MdbCheckboxChange {}\n\nlet MdbCheckboxDirective = /*#__PURE__*/(() => {\n  class MdbCheckboxDirective {\n    constructor() {\n      this._checked = false;\n      this._value = null;\n      this._disabled = false;\n      this.checkboxChange = new EventEmitter(); // Control Value Accessor Methods\n\n      this.onChange = _ => {};\n\n      this.onTouched = () => {};\n    }\n\n    get checked() {\n      return this._checked;\n    }\n\n    set checked(value) {\n      this._checked = value;\n    }\n\n    get value() {\n      return this._value;\n    }\n\n    set value(value) {\n      this._value = value;\n    }\n\n    get disabled() {\n      return this._disabled;\n    }\n\n    set disabled(value) {\n      this._disabled = value;\n    }\n\n    get isDisabled() {\n      return this._disabled;\n    }\n\n    get isChecked() {\n      return this._checked;\n    }\n\n    onCheckboxClick() {\n      this.toggle();\n    }\n\n    onBlur() {\n      this.onTouched();\n    }\n\n    get changeEvent() {\n      const newChangeEvent = new MdbCheckboxChange();\n      newChangeEvent.element = this;\n      newChangeEvent.checked = this.checked;\n      return newChangeEvent;\n    }\n\n    toggle() {\n      if (this.disabled) {\n        return;\n      }\n\n      this._checked = !this._checked;\n      this.onChange(this.checked);\n      this.onCheckboxChange();\n    }\n\n    onCheckboxChange() {\n      this.checkboxChange.emit(this.changeEvent);\n    }\n\n    writeValue(value) {\n      this.value = value;\n      this.checked = !!value;\n    }\n\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n\n  }\n\n  MdbCheckboxDirective.ɵfac = function MdbCheckboxDirective_Factory(t) {\n    return new (t || MdbCheckboxDirective)();\n  };\n\n  MdbCheckboxDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbCheckboxDirective,\n    selectors: [[\"\", \"mdbCheckbox\", \"\"]],\n    hostVars: 2,\n    hostBindings: function MdbCheckboxDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function MdbCheckboxDirective_click_HostBindingHandler() {\n          return ctx.onCheckboxClick();\n        })(\"blur\", function MdbCheckboxDirective_blur_HostBindingHandler() {\n          return ctx.onBlur();\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"disabled\", ctx.isDisabled)(\"checked\", ctx.isChecked);\n      }\n    },\n    inputs: {\n      checked: \"checked\",\n      value: \"value\",\n      disabled: \"disabled\"\n    },\n    outputs: {\n      checkboxChange: \"checkboxChange\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([MDB_CHECKBOX_VALUE_ACCESSOR])]\n  });\n  return MdbCheckboxDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbCheckboxModule = /*#__PURE__*/(() => {\n  class MdbCheckboxModule {}\n\n  MdbCheckboxModule.ɵfac = function MdbCheckboxModule_Factory(t) {\n    return new (t || MdbCheckboxModule)();\n  };\n\n  MdbCheckboxModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdbCheckboxModule\n  });\n  MdbCheckboxModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, FormsModule]]\n  });\n  return MdbCheckboxModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbCheckboxModule, {\n    declarations: function () {\n      return [MdbCheckboxDirective];\n    },\n    imports: function () {\n      return [CommonModule, FormsModule];\n    },\n    exports: function () {\n      return [MdbCheckboxDirective];\n    }\n  });\n})();\n\nlet MdbRadioDirective = /*#__PURE__*/(() => {\n  class MdbRadioDirective {\n    constructor() {\n      this._checked = false;\n      this._value = null;\n      this._disabled = false;\n    }\n\n    get name() {\n      return this._name;\n    }\n\n    set name(value) {\n      this._name = value;\n    }\n\n    get checked() {\n      return this._checked;\n    }\n\n    set checked(value) {\n      this._checked = value;\n    }\n\n    get value() {\n      return this._value;\n    }\n\n    set value(value) {\n      this._value = value;\n    }\n\n    get disabled() {\n      return this._disabled;\n    }\n\n    set disabled(value) {\n      this._disabled = value;\n    }\n\n    get isDisabled() {\n      return this._disabled;\n    }\n\n    get isChecked() {\n      return this._checked;\n    }\n\n    get nameAttr() {\n      return this.name;\n    }\n\n    _updateName(value) {\n      this._name = value;\n    }\n\n    _updateChecked(value) {\n      this._checked = value;\n    }\n\n    _updateDisabledState(value) {\n      this._disabled = value;\n    }\n\n  }\n\n  MdbRadioDirective.ɵfac = function MdbRadioDirective_Factory(t) {\n    return new (t || MdbRadioDirective)();\n  };\n\n  MdbRadioDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbRadioDirective,\n    selectors: [[\"\", \"mdbRadio\", \"\"]],\n    hostVars: 3,\n    hostBindings: function MdbRadioDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"disabled\", ctx.isDisabled)(\"checked\", ctx.isChecked);\n        ɵngcc0.ɵɵattribute(\"name\", ctx.nameAttr);\n      }\n    },\n    inputs: {\n      name: \"name\",\n      checked: \"checked\",\n      value: \"value\",\n      disabled: \"disabled\"\n    }\n  });\n  return MdbRadioDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst MDB_RADIO_GROUP_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  // tslint:disable-next-line: no-use-before-declare\n  useExisting: forwardRef(() => MdbRadioGroupDirective),\n  multi: true\n};\nlet MdbRadioGroupDirective = /*#__PURE__*/(() => {\n  class MdbRadioGroupDirective {\n    constructor() {\n      this._disabled = false;\n      this._destroy$ = new Subject();\n\n      this.onChange = _ => {};\n\n      this.onTouched = () => {};\n    }\n\n    get value() {\n      return this._value;\n    }\n\n    set value(value) {\n      this._value = value;\n\n      if (this.radios) {\n        this._updateChecked();\n      }\n    }\n\n    get name() {\n      return this._name;\n    }\n\n    set name(name) {\n      this._name = name;\n\n      if (this.radios) {\n        this._updateNames();\n      }\n    }\n\n    get disabled() {\n      return this._disabled;\n    }\n\n    set disabled(disabled) {\n      this._disabled = disabled;\n\n      if (this.radios) {\n        this._updateDisabled();\n      }\n    }\n\n    ngAfterContentInit() {\n      this._updateNames();\n\n      this._updateDisabled();\n\n      this.radios.changes.pipe(startWith(this.radios), switchMap(radios => from(Promise.resolve(radios))), takeUntil(this._destroy$)).subscribe(() => this._updateRadiosState());\n    }\n\n    ngOnDestroy() {\n      this._destroy$.next();\n\n      this._destroy$.complete();\n    }\n\n    _updateRadiosState() {\n      this._updateNames();\n\n      this._updateChecked();\n\n      this._updateDisabled();\n    }\n\n    _updateNames() {\n      this.radios.forEach(radio => radio._updateName(this.name));\n    }\n\n    _updateChecked() {\n      this.radios.forEach(radio => {\n        const isChecked = radio.value === this._value;\n\n        radio._updateChecked(isChecked);\n      });\n    }\n\n    _updateDisabled() {\n      this.radios.forEach(radio => radio._updateDisabledState(this._disabled));\n    } // Control value accessor methods\n\n\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n\n    setDisabledState(isDisabled) {\n      this._disabled = isDisabled;\n\n      this._updateDisabled();\n    }\n\n    writeValue(value) {\n      this.value = value;\n    }\n\n  }\n\n  MdbRadioGroupDirective.ɵfac = function MdbRadioGroupDirective_Factory(t) {\n    return new (t || MdbRadioGroupDirective)();\n  };\n\n  MdbRadioGroupDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbRadioGroupDirective,\n    selectors: [[\"\", \"mdbRadioGroup\", \"\"]],\n    contentQueries: function MdbRadioGroupDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdbRadioDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.radios = _t);\n      }\n    },\n    inputs: {\n      value: \"value\",\n      name: \"name\",\n      disabled: \"disabled\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([MDB_RADIO_GROUP_VALUE_ACCESSOR])]\n  });\n  return MdbRadioGroupDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbRadioModule = /*#__PURE__*/(() => {\n  class MdbRadioModule {}\n\n  MdbRadioModule.ɵfac = function MdbRadioModule_Factory(t) {\n    return new (t || MdbRadioModule)();\n  };\n\n  MdbRadioModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdbRadioModule\n  });\n  MdbRadioModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, FormsModule]]\n  });\n  return MdbRadioModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbRadioModule, {\n    declarations: function () {\n      return [MdbRadioDirective, MdbRadioGroupDirective];\n    },\n    imports: function () {\n      return [CommonModule, FormsModule];\n    },\n    exports: function () {\n      return [MdbRadioDirective, MdbRadioGroupDirective];\n    }\n  });\n})();\n\nlet MdbTooltipComponent = /*#__PURE__*/(() => {\n  class MdbTooltipComponent {\n    constructor(_cdRef) {\n      this._cdRef = _cdRef;\n      this._hidden = new Subject();\n      this.animationState = 'hidden';\n    }\n\n    ngOnInit() {}\n\n    markForCheck() {\n      this._cdRef.markForCheck();\n    }\n\n    onAnimationEnd(event) {\n      if (event.toState === 'hidden') {\n        this._hidden.next();\n      }\n    }\n\n  }\n\n  MdbTooltipComponent.ɵfac = function MdbTooltipComponent_Factory(t) {\n    return new (t || MdbTooltipComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  MdbTooltipComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdbTooltipComponent,\n    selectors: [[\"mdb-tooltip\"]],\n    inputs: {\n      title: \"title\",\n      html: \"html\",\n      animation: \"animation\"\n    },\n    decls: 2,\n    vars: 2,\n    consts: [[\"class\", \"tooltip-inner\", 3, \"innerHTML\", 4, \"ngIf\"], [\"class\", \"tooltip-inner\", 4, \"ngIf\"], [1, \"tooltip-inner\", 3, \"innerHTML\"], [1, \"tooltip-inner\"]],\n    template: function MdbTooltipComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵtemplate(0, MdbTooltipComponent_div_0_Template, 1, 3, \"div\", 0);\n        ɵngcc0.ɵɵtemplate(1, MdbTooltipComponent_div_1_Template, 2, 3, \"div\", 1);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.html);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.html);\n      }\n    },\n    directives: [ɵngcc1.NgIf],\n    encapsulation: 2,\n    data: {\n      animation: [trigger('fade', [state('visible', style({\n        opacity: 1\n      })), state('hidden', style({\n        opacity: 0\n      })), transition('visible => hidden', animate('150ms linear')), transition(':enter', animate('150ms linear'))])]\n    },\n    changeDetection: 0\n  });\n  return MdbTooltipComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable-next-line:component-class-suffix\n\n\nlet MdbTooltipDirective = /*#__PURE__*/(() => {\n  class MdbTooltipDirective {\n    constructor(_overlay, _overlayPositionBuilder, _elementRef, _renderer) {\n      this._overlay = _overlay;\n      this._overlayPositionBuilder = _overlayPositionBuilder;\n      this._elementRef = _elementRef;\n      this._renderer = _renderer;\n      this.mdbTooltip = '';\n      this.tooltipDisabled = false;\n      this.placement = 'top';\n      this.html = false;\n      this.animation = true;\n      this.trigger = 'hover focus';\n      this.delayShow = 0;\n      this.delayHide = 0;\n      this.offset = 4;\n      this.tooltipShow = new EventEmitter();\n      this.tooltipShown = new EventEmitter();\n      this.tooltipHide = new EventEmitter();\n      this.tooltipHidden = new EventEmitter();\n      this._open = false;\n      this._showTimeout = 0;\n      this._hideTimeout = 0;\n      this._destroy$ = new Subject();\n    }\n\n    ngOnInit() {\n      if (this.tooltipDisabled) {\n        return;\n      }\n\n      this._bindTriggerEvents();\n\n      this._createOverlay();\n    }\n\n    ngOnDestroy() {\n      if (this._open) {\n        this.hide();\n      }\n\n      this._destroy$.next();\n\n      this._destroy$.complete();\n    }\n\n    _bindTriggerEvents() {\n      const triggers = this.trigger.split(' ');\n      triggers.forEach(trigger => {\n        if (trigger === 'click') {\n          fromEvent(this._elementRef.nativeElement, trigger).pipe(takeUntil(this._destroy$)).subscribe(() => this.toggle());\n        } else if (trigger !== 'manual') {\n          const evIn = trigger === 'hover' ? 'mouseenter' : 'focusin';\n          const evOut = trigger === 'hover' ? 'mouseleave' : 'focusout';\n          fromEvent(this._elementRef.nativeElement, evIn).pipe(takeUntil(this._destroy$)).subscribe(() => this.show());\n          fromEvent(this._elementRef.nativeElement, evOut).pipe(takeUntil(this._destroy$)).subscribe(() => this.hide());\n        }\n      });\n    }\n\n    _createOverlayConfig() {\n      const positionStrategy = this._overlayPositionBuilder.flexibleConnectedTo(this._elementRef).withPositions(this._getPosition());\n\n      const overlayConfig = new OverlayConfig({\n        hasBackdrop: false,\n        scrollStrategy: this._overlay.scrollStrategies.reposition(),\n        positionStrategy\n      });\n      return overlayConfig;\n    }\n\n    _createOverlay() {\n      this._overlayRef = this._overlay.create(this._createOverlayConfig());\n    }\n\n    _getPosition() {\n      let position;\n      const positionTop = {\n        originX: 'center',\n        originY: 'top',\n        overlayX: 'center',\n        overlayY: 'bottom',\n        offsetY: -this.offset\n      };\n      const positionBottom = {\n        originX: 'center',\n        originY: 'bottom',\n        overlayX: 'center',\n        overlayY: 'top',\n        offsetY: this.offset\n      };\n      const positionRight = {\n        originX: 'end',\n        originY: 'center',\n        overlayX: 'start',\n        overlayY: 'center',\n        offsetX: this.offset\n      };\n      const positionLeft = {\n        originX: 'start',\n        originY: 'center',\n        overlayX: 'end',\n        overlayY: 'center',\n        offsetX: -this.offset\n      };\n\n      switch (this.placement) {\n        case 'top':\n          position = [positionTop, positionBottom];\n          break;\n\n        case 'bottom':\n          position = [positionBottom, positionTop];\n          break;\n\n        case 'left':\n          position = [positionLeft, positionRight];\n          break;\n\n        case 'right':\n          position = [positionRight, positionLeft];\n          break;\n\n        default:\n          break;\n      }\n\n      return position;\n    }\n\n    show() {\n      if (this._open) {\n        this._overlayRef.detach();\n      }\n\n      if (this._hideTimeout) {\n        clearTimeout(this._hideTimeout);\n        this._hideTimeout = null;\n      }\n\n      this._showTimeout = setTimeout(() => {\n        const tooltipPortal = new ComponentPortal(MdbTooltipComponent);\n        this.tooltipShow.emit(this);\n        this._open = true;\n        this._tooltipRef = this._overlayRef.attach(tooltipPortal);\n        this._tooltipRef.instance.title = this.mdbTooltip;\n        this._tooltipRef.instance.html = this.html;\n        this._tooltipRef.instance.animation = this.animation;\n        this._tooltipRef.instance.animationState = 'visible';\n\n        this._tooltipRef.instance.markForCheck();\n\n        this.tooltipShown.emit(this);\n      }, this.delayShow);\n    }\n\n    hide() {\n      if (!this._open) {\n        return;\n      }\n\n      if (this._showTimeout) {\n        clearTimeout(this._showTimeout);\n        this._showTimeout = null;\n      }\n\n      this._hideTimeout = setTimeout(() => {\n        this.tooltipHide.emit(this);\n\n        this._tooltipRef.instance._hidden.pipe(first()).subscribe(() => {\n          this._overlayRef.detach();\n\n          this._open = false;\n          this.tooltipShown.emit(this);\n        });\n\n        this._tooltipRef.instance.animationState = 'hidden';\n\n        this._tooltipRef.instance.markForCheck();\n      }, this.delayHide);\n    }\n\n    toggle() {\n      if (this._open) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    }\n\n  }\n\n  MdbTooltipDirective.ɵfac = function MdbTooltipDirective_Factory(t) {\n    return new (t || MdbTooltipDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.OverlayPositionBuilder), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  MdbTooltipDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbTooltipDirective,\n    selectors: [[\"\", \"mdbTooltip\", \"\"]],\n    inputs: {\n      mdbTooltip: \"mdbTooltip\",\n      tooltipDisabled: \"tooltipDisabled\",\n      placement: \"placement\",\n      html: \"html\",\n      animation: \"animation\",\n      trigger: \"trigger\",\n      delayShow: \"delayShow\",\n      delayHide: \"delayHide\",\n      offset: \"offset\"\n    },\n    outputs: {\n      tooltipShow: \"tooltipShow\",\n      tooltipShown: \"tooltipShown\",\n      tooltipHide: \"tooltipHide\",\n      tooltipHidden: \"tooltipHidden\"\n    },\n    exportAs: [\"mdbTooltip\"]\n  });\n  return MdbTooltipDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbTooltipModule = /*#__PURE__*/(() => {\n  class MdbTooltipModule {}\n\n  MdbTooltipModule.ɵfac = function MdbTooltipModule_Factory(t) {\n    return new (t || MdbTooltipModule)();\n  };\n\n  MdbTooltipModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdbTooltipModule\n  });\n  MdbTooltipModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, OverlayModule]]\n  });\n  return MdbTooltipModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbTooltipModule, {\n    declarations: function () {\n      return [MdbTooltipDirective, MdbTooltipComponent];\n    },\n    imports: function () {\n      return [CommonModule, OverlayModule];\n    },\n    exports: function () {\n      return [MdbTooltipDirective, MdbTooltipComponent];\n    }\n  });\n})();\n\nlet MdbPopoverComponent = /*#__PURE__*/(() => {\n  class MdbPopoverComponent {\n    constructor(_cdRef) {\n      this._cdRef = _cdRef;\n      this._hidden = new Subject();\n      this.animationState = 'hidden';\n    }\n\n    ngOnInit() {}\n\n    markForCheck() {\n      this._cdRef.markForCheck();\n    }\n\n    onAnimationEnd(event) {\n      if (event.toState === 'hidden') {\n        this._hidden.next();\n      }\n    }\n\n  }\n\n  MdbPopoverComponent.ɵfac = function MdbPopoverComponent_Factory(t) {\n    return new (t || MdbPopoverComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  MdbPopoverComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdbPopoverComponent,\n    selectors: [[\"mdb-popover\"]],\n    inputs: {\n      title: \"title\",\n      content: \"content\",\n      template: \"template\",\n      animation: \"animation\"\n    },\n    decls: 4,\n    vars: 5,\n    consts: [[1, \"popover\"], [\"class\", \"popover-header\", 4, \"ngIf\"], [\"class\", \"popover-body\", 3, \"innerHTML\", 4, \"ngIf\"], [\"class\", \"popover-body\", 4, \"ngIf\"], [1, \"popover-header\"], [1, \"popover-body\", 3, \"innerHTML\"], [1, \"popover-body\"]],\n    template: function MdbPopoverComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵlistener(\"@fade.done\", function MdbPopoverComponent_Template_div_animation_fade_done_0_listener($event) {\n          return ctx.onAnimationEnd($event);\n        });\n        ɵngcc0.ɵɵtemplate(1, MdbPopoverComponent_div_1_Template, 2, 1, \"div\", 1);\n        ɵngcc0.ɵɵtemplate(2, MdbPopoverComponent_div_2_Template, 1, 1, \"div\", 2);\n        ɵngcc0.ɵɵtemplate(3, MdbPopoverComponent_div_3_Template, 2, 1, \"div\", 3);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"@fade\", ctx.animationState)(\"@.disabled\", !ctx.animation);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.title);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.template);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.template);\n      }\n    },\n    directives: [ɵngcc1.NgIf],\n    encapsulation: 2,\n    data: {\n      animation: [trigger('fade', [state('visible', style({\n        opacity: 1\n      })), state('hidden', style({\n        opacity: 0\n      })), transition('visible <=> hidden', animate('150ms linear')), transition(':enter', animate('150ms linear'))])]\n    },\n    changeDetection: 0\n  });\n  return MdbPopoverComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable-next-line:component-class-suffix\n\n\nlet MdbPopoverDirective = /*#__PURE__*/(() => {\n  class MdbPopoverDirective {\n    constructor(_overlay, _overlayPositionBuilder, _elementRef) {\n      this._overlay = _overlay;\n      this._overlayPositionBuilder = _overlayPositionBuilder;\n      this._elementRef = _elementRef;\n      this.mdbPopover = '';\n      this.mdbPopoverTitle = '';\n      this.popoverDisabled = false;\n      this.placement = 'top';\n      this.template = false;\n      this.animation = true;\n      this.trigger = 'click';\n      this.delayShow = 0;\n      this.delayHide = 0;\n      this.offset = 4;\n      this.popoverShow = new EventEmitter();\n      this.popoverShown = new EventEmitter();\n      this.popoverHide = new EventEmitter();\n      this.popoverHidden = new EventEmitter();\n      this._open = false;\n      this._showTimeout = 0;\n      this._hideTimeout = 0;\n      this._destroy$ = new Subject();\n    }\n\n    ngOnInit() {\n      if (this.popoverDisabled) {\n        return;\n      }\n\n      this._bindTriggerEvents();\n\n      this._createOverlay();\n    }\n\n    ngOnDestroy() {\n      if (this._open) {\n        this.hide();\n      }\n\n      this._destroy$.next();\n\n      this._destroy$.complete();\n    }\n\n    _bindTriggerEvents() {\n      const triggers = this.trigger.split(' ');\n      triggers.forEach(trigger => {\n        if (trigger === 'click') {\n          fromEvent(this._elementRef.nativeElement, trigger).pipe(takeUntil(this._destroy$)).subscribe(() => this.toggle());\n        } else if (trigger !== 'manual') {\n          const evIn = trigger === 'hover' ? 'mouseenter' : 'focusin';\n          const evOut = trigger === 'hover' ? 'mouseleave' : 'focusout';\n          fromEvent(this._elementRef.nativeElement, evIn).pipe(takeUntil(this._destroy$)).subscribe(() => this.show());\n          fromEvent(this._elementRef.nativeElement, evOut).pipe(takeUntil(this._destroy$)).subscribe(() => this.hide());\n        }\n      });\n    }\n\n    _createOverlayConfig() {\n      const positionStrategy = this._overlayPositionBuilder.flexibleConnectedTo(this._elementRef).withPositions(this._getPosition());\n\n      const overlayConfig = new OverlayConfig({\n        hasBackdrop: false,\n        scrollStrategy: this._overlay.scrollStrategies.reposition(),\n        positionStrategy\n      });\n      return overlayConfig;\n    }\n\n    _createOverlay() {\n      this._overlayRef = this._overlay.create(this._createOverlayConfig());\n    }\n\n    _getPosition() {\n      let position;\n      const positionTop = {\n        originX: 'center',\n        originY: 'top',\n        overlayX: 'center',\n        overlayY: 'bottom',\n        offsetY: -this.offset\n      };\n      const positionBottom = {\n        originX: 'center',\n        originY: 'bottom',\n        overlayX: 'center',\n        overlayY: 'top',\n        offsetY: this.offset\n      };\n      const positionRight = {\n        originX: 'end',\n        originY: 'center',\n        overlayX: 'start',\n        overlayY: 'center',\n        offsetX: this.offset\n      };\n      const positionLeft = {\n        originX: 'start',\n        originY: 'center',\n        overlayX: 'end',\n        overlayY: 'center',\n        offsetX: -this.offset\n      };\n\n      switch (this.placement) {\n        case 'top':\n          position = [positionTop, positionBottom];\n          break;\n\n        case 'bottom':\n          position = [positionBottom, positionTop];\n          break;\n\n        case 'left':\n          position = [positionLeft, positionRight, positionTop, positionBottom];\n          break;\n\n        case 'right':\n          position = [positionRight, positionLeft, positionTop, positionBottom];\n          break;\n\n        default:\n          break;\n      }\n\n      return position;\n    }\n\n    show() {\n      if (this._open) {\n        this._overlayRef.detach();\n      }\n\n      if (this._hideTimeout) {\n        clearTimeout(this._hideTimeout);\n        this._hideTimeout = null;\n      }\n\n      this._showTimeout = setTimeout(() => {\n        const tooltipPortal = new ComponentPortal(MdbPopoverComponent);\n        this.popoverShow.emit(this);\n        this._open = true;\n        this._tooltipRef = this._overlayRef.attach(tooltipPortal);\n        this._tooltipRef.instance.content = this.mdbPopover;\n        this._tooltipRef.instance.title = this.mdbPopoverTitle;\n        this._tooltipRef.instance.template = this.template;\n        this._tooltipRef.instance.animation = this.animation;\n        this._tooltipRef.instance.animationState = 'visible';\n\n        this._tooltipRef.instance.markForCheck();\n\n        this.popoverShown.emit(this);\n      }, this.delayShow);\n    }\n\n    hide() {\n      if (!this._open) {\n        return;\n      }\n\n      if (this._showTimeout) {\n        clearTimeout(this._showTimeout);\n        this._showTimeout = null;\n      }\n\n      this._hideTimeout = setTimeout(() => {\n        this.popoverHide.emit(this);\n\n        this._tooltipRef.instance._hidden.pipe(first()).subscribe(() => {\n          this._overlayRef.detach();\n\n          this._open = false;\n          this.popoverShown.emit(this);\n        });\n\n        this._tooltipRef.instance.animationState = 'hidden';\n\n        this._tooltipRef.instance.markForCheck();\n      }, this.delayHide);\n    }\n\n    toggle() {\n      if (this._open) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    }\n\n  }\n\n  MdbPopoverDirective.ɵfac = function MdbPopoverDirective_Factory(t) {\n    return new (t || MdbPopoverDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.OverlayPositionBuilder), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdbPopoverDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbPopoverDirective,\n    selectors: [[\"\", \"mdbPopover\", \"\"]],\n    inputs: {\n      mdbPopover: \"mdbPopover\",\n      mdbPopoverTitle: \"mdbPopoverTitle\",\n      popoverDisabled: \"popoverDisabled\",\n      placement: \"placement\",\n      template: \"template\",\n      animation: \"animation\",\n      trigger: \"trigger\",\n      delayShow: \"delayShow\",\n      delayHide: \"delayHide\",\n      offset: \"offset\"\n    },\n    outputs: {\n      popoverShow: \"popoverShow\",\n      popoverShown: \"popoverShown\",\n      popoverHide: \"popoverHide\",\n      popoverHidden: \"popoverHidden\"\n    },\n    exportAs: [\"mdbPopover\"]\n  });\n  return MdbPopoverDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbPopoverModule = /*#__PURE__*/(() => {\n  class MdbPopoverModule {}\n\n  MdbPopoverModule.ɵfac = function MdbPopoverModule_Factory(t) {\n    return new (t || MdbPopoverModule)();\n  };\n\n  MdbPopoverModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdbPopoverModule\n  });\n  MdbPopoverModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, OverlayModule]]\n  });\n  return MdbPopoverModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbPopoverModule, {\n    declarations: function () {\n      return [MdbPopoverDirective, MdbPopoverComponent];\n    },\n    imports: function () {\n      return [CommonModule, OverlayModule];\n    },\n    exports: function () {\n      return [MdbPopoverDirective, MdbPopoverComponent];\n    }\n  });\n})(); // tslint:disable-next-line: directive-class-suffix\n\n\nlet MdbAbstractFormControl = /*#__PURE__*/(() => {\n  class MdbAbstractFormControl {}\n\n  MdbAbstractFormControl.ɵfac = function MdbAbstractFormControl_Factory(t) {\n    return new (t || MdbAbstractFormControl)();\n  };\n\n  MdbAbstractFormControl.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbAbstractFormControl\n  });\n  return MdbAbstractFormControl;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable-next-line: component-class-suffix\n\n\nlet MdbInputDirective = /*#__PURE__*/(() => {\n  class MdbInputDirective {\n    constructor(_elementRef, _renderer) {\n      this._elementRef = _elementRef;\n      this._renderer = _renderer;\n      this.stateChanges = new Subject();\n      this._focused = false;\n      this._disabled = false;\n      this._readonly = false;\n    }\n\n    get disabled() {\n      return this._disabled;\n    }\n\n    set disabled(value) {\n      this._disabled = value;\n    }\n\n    get readonly() {\n      return this._readonly;\n    }\n\n    set readonly(value) {\n      if (value) {\n        this._renderer.setAttribute(this._elementRef.nativeElement, 'readonly', '');\n      } else {\n        this._renderer.removeAttribute(this._elementRef.nativeElement, 'readonly');\n      }\n\n      this._readonly = value;\n    }\n\n    get value() {\n      return this._elementRef.nativeElement.value;\n    }\n\n    set value(value) {\n      if (value !== this.value) {\n        this._elementRef.nativeElement.value = value;\n        this.stateChanges.next();\n      }\n    }\n\n    _onFocus() {\n      this._focused = true;\n      this.stateChanges.next();\n    }\n\n    _onBlur() {\n      this._focused = false;\n      this.stateChanges.next();\n    }\n\n    get hasValue() {\n      return this._elementRef.nativeElement.value !== '';\n    }\n\n    get focused() {\n      return this._focused;\n    }\n\n    get labelActive() {\n      return this.focused || this.hasValue;\n    }\n\n  }\n\n  MdbInputDirective.ɵfac = function MdbInputDirective_Factory(t) {\n    return new (t || MdbInputDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  MdbInputDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbInputDirective,\n    selectors: [[\"\", \"mdbInput\", \"\"]],\n    hostVars: 1,\n    hostBindings: function MdbInputDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"focus\", function MdbInputDirective_focus_HostBindingHandler() {\n          return ctx._onFocus();\n        })(\"blur\", function MdbInputDirective_blur_HostBindingHandler() {\n          return ctx._onBlur();\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵhostProperty(\"disabled\", ctx.disabled);\n      }\n    },\n    inputs: {\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      value: \"value\"\n    },\n    exportAs: [\"mdbInput\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: MdbAbstractFormControl,\n      useExisting: MdbInputDirective\n    }])]\n  });\n  return MdbInputDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable-next-line: component-class-suffix\n\n\nlet MdbLabelDirective = /*#__PURE__*/(() => {\n  class MdbLabelDirective {\n    constructor() {}\n\n  }\n\n  MdbLabelDirective.ɵfac = function MdbLabelDirective_Factory(t) {\n    return new (t || MdbLabelDirective)();\n  };\n\n  MdbLabelDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbLabelDirective,\n    selectors: [[\"\", \"mdbLabel\", \"\"]],\n    exportAs: [\"mdbLabel\"]\n  });\n  return MdbLabelDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbFormControlComponent = /*#__PURE__*/(() => {\n  class MdbFormControlComponent {\n    constructor(_renderer, _contentObserver) {\n      this._renderer = _renderer;\n      this._contentObserver = _contentObserver;\n      this.outline = true;\n      this._destroy$ = new Subject();\n      this._notchLeadingLength = 9;\n      this._labelMarginLeft = 0;\n      this._labelGapPadding = 8;\n      this._labelScale = 0.8;\n    }\n\n    ngAfterViewInit() {}\n\n    ngAfterContentInit() {\n      if (this._label) {\n        this._updateBorderGap();\n      } else {\n        this._renderer.addClass(this._input.nativeElement, 'placeholder-active');\n      }\n\n      this._updateLabelActiveState();\n\n      if (this._label) {\n        this._contentObserver.observe(this._label.nativeElement).pipe(takeUntil(this._destroy$)).subscribe(() => {\n          this._updateBorderGap();\n        });\n      }\n\n      this._formControl.stateChanges.pipe(takeUntil(this._destroy$)).subscribe(() => {\n        this._updateLabelActiveState();\n\n        if (this._label) {\n          this._updateBorderGap();\n        }\n      });\n    }\n\n    ngOnDestroy() {\n      this._destroy$.next();\n\n      this._destroy$.unsubscribe();\n    }\n\n    _getLabelWidth() {\n      return this._label.nativeElement.clientWidth * this._labelScale + this._labelGapPadding;\n    }\n\n    _updateBorderGap() {\n      const notchLeadingWidth = `${this._labelMarginLeft + this._notchLeadingLength}px`;\n      const notchMiddleWidth = `${this._getLabelWidth()}px`;\n\n      this._renderer.setStyle(this._notchLeading.nativeElement, 'width', notchLeadingWidth);\n\n      this._renderer.setStyle(this._notchMiddle.nativeElement, 'width', notchMiddleWidth);\n\n      this._renderer.setStyle(this._label.nativeElement, 'margin-left', `${this._labelMarginLeft}px`);\n    }\n\n    _updateLabelActiveState() {\n      if (this._isLabelActive()) {\n        this._renderer.addClass(this._input.nativeElement, 'active');\n      } else {\n        this._renderer.removeClass(this._input.nativeElement, 'active');\n      }\n    }\n\n    _isLabelActive() {\n      return this._formControl && this._formControl.labelActive;\n    }\n\n  }\n\n  MdbFormControlComponent.ɵfac = function MdbFormControlComponent_Factory(t) {\n    return new (t || MdbFormControlComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.ContentObserver));\n  };\n\n  MdbFormControlComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdbFormControlComponent,\n    selectors: [[\"mdb-form-control\"]],\n    contentQueries: function MdbFormControlComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdbInputDirective, 7, ElementRef);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdbAbstractFormControl, 7);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdbLabelDirective, 7, ElementRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._input = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._formControl = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._label = _t.first);\n      }\n    },\n    viewQuery: function MdbFormControlComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 7);\n        ɵngcc0.ɵɵviewQuery(_c1, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._notchLeading = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._notchMiddle = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function MdbFormControlComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"form-outline\", ctx.outline);\n      }\n    },\n    ngContentSelectors: _c2,\n    decls: 7,\n    vars: 0,\n    consts: [[1, \"form-notch\"], [1, \"form-notch-leading\"], [\"notchLeading\", \"\"], [1, \"form-notch-middle\"], [\"notchMiddle\", \"\"], [1, \"form-notch-trailing\"]],\n    template: function MdbFormControlComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n        ɵngcc0.ɵɵelementStart(1, \"div\", 0);\n        ɵngcc0.ɵɵelement(2, \"div\", 1, 2)(4, \"div\", 3, 4)(6, \"div\", 5);\n        ɵngcc0.ɵɵelementEnd();\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MdbFormControlComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbFormsModule = /*#__PURE__*/(() => {\n  class MdbFormsModule {}\n\n  MdbFormsModule.ɵfac = function MdbFormsModule_Factory(t) {\n    return new (t || MdbFormsModule)();\n  };\n\n  MdbFormsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdbFormsModule\n  });\n  MdbFormsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, FormsModule]]\n  });\n  return MdbFormsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbFormsModule, {\n    declarations: function () {\n      return [MdbFormControlComponent, MdbInputDirective, MdbLabelDirective];\n    },\n    imports: function () {\n      return [CommonModule, FormsModule];\n    },\n    exports: function () {\n      return [MdbFormControlComponent, MdbInputDirective, MdbLabelDirective];\n    }\n  });\n})();\n\nlet MdbModalContainerComponent = /*#__PURE__*/(() => {\n  class MdbModalContainerComponent {\n    constructor(_document, _elementRef, _renderer, _focusTrapFactory) {\n      this._document = _document;\n      this._elementRef = _elementRef;\n      this._renderer = _renderer;\n      this._focusTrapFactory = _focusTrapFactory;\n      this._destroy$ = new Subject();\n      this.backdropClick$ = new Subject();\n      this.BACKDROP_TRANSITION = 150;\n      this.MODAL_TRANSITION = 200;\n      this.modal = true;\n    }\n\n    get hasAnimation() {\n      return this._config.animation;\n    }\n\n    ngOnInit() {\n      this._updateContainerClass();\n\n      this._renderer.addClass(this._document.body, 'modal-open');\n\n      this._renderer.setStyle(this._document.body, 'padding-right', '15px');\n\n      this._renderer.setStyle(this._elementRef.nativeElement, 'display', 'block');\n\n      this._previouslyFocusedElement = this._document.activeElement;\n      this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\n\n      if (this._config.animation) {\n        setTimeout(() => {\n          this._renderer.addClass(this._elementRef.nativeElement, 'show');\n\n          setTimeout(() => {\n            this._focusTrap.focusInitialElementWhenReady();\n          }, this.MODAL_TRANSITION);\n        }, this.BACKDROP_TRANSITION);\n      } else {\n        this._focusTrap.focusInitialElementWhenReady();\n      }\n    }\n\n    ngAfterViewInit() {\n      if (!this._config.ignoreBackdropClick) {\n        fromEvent(this._elementRef.nativeElement, 'click').pipe(filter(event => {\n          const target = event.target;\n          const dialog = this.modalDialog.nativeElement;\n          const notDialog = target !== dialog;\n          const notDialogContent = !dialog.contains(target);\n          return notDialog && notDialogContent;\n        }), takeUntil(this._destroy$)).subscribe(event => {\n          this.backdropClick$.next(event);\n        });\n      }\n    }\n\n    ngOnDestroy() {\n      this._previouslyFocusedElement.focus();\n\n      this._focusTrap.destroy();\n\n      this._destroy$.next();\n\n      this._destroy$.complete();\n    }\n\n    _updateContainerClass() {\n      if (this._config.containerClass === '' || this._config.containerClass.length && this._config.containerClass.length === 0) {\n        return;\n      }\n\n      const containerClasses = this._config.containerClass.split(' ');\n\n      containerClasses.forEach(containerClass => {\n        this._renderer.addClass(this._elementRef.nativeElement, containerClass);\n      });\n    }\n\n    _close() {\n      if (this._config.animation) {\n        this._renderer.removeClass(this._elementRef.nativeElement, 'show');\n      } // Pause iframe/video when closing modal\n\n\n      const iframeElements = Array.from(this._elementRef.nativeElement.querySelectorAll('iframe'));\n      const videoElements = Array.from(this._elementRef.nativeElement.querySelectorAll('video'));\n      iframeElements.forEach(iframe => {\n        const srcAttribute = iframe.getAttribute('src');\n\n        this._renderer.setAttribute(iframe, 'src', srcAttribute);\n      });\n      videoElements.forEach(video => {\n        video.pause();\n      });\n    }\n\n    _restoreScrollbar() {\n      this._renderer.removeClass(this._document.body, 'modal-open');\n\n      this._renderer.removeStyle(this._document.body, 'padding-right');\n    }\n\n    attachComponentPortal(portal) {\n      return this._portalOutlet.attachComponentPortal(portal);\n    }\n\n    attachTemplatePortal(portal) {\n      return this._portalOutlet.attachTemplatePortal(portal);\n    }\n\n  }\n\n  MdbModalContainerComponent.ɵfac = function MdbModalContainerComponent_Factory(t) {\n    return new (t || MdbModalContainerComponent)(ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.ConfigurableFocusTrapFactory));\n  };\n\n  MdbModalContainerComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdbModalContainerComponent,\n    selectors: [[\"mdb-modal-container\"]],\n    viewQuery: function MdbModalContainerComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(CdkPortalOutlet, 7);\n        ɵngcc0.ɵɵviewQuery(_c3, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._portalOutlet = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.modalDialog = _t.first);\n      }\n    },\n    hostVars: 4,\n    hostBindings: function MdbModalContainerComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"modal\", ctx.modal)(\"fade\", ctx.hasAnimation);\n      }\n    },\n    decls: 4,\n    vars: 2,\n    consts: [[\"dialog\", \"\"], [1, \"modal-content\"], [\"cdkPortalOutlet\", \"\"]],\n    template: function MdbModalContainerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", null, 0)(2, \"div\", 1);\n        ɵngcc0.ɵɵtemplate(3, MdbModalContainerComponent_ng_template_3_Template, 0, 0, \"ng-template\", 2);\n        ɵngcc0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassMap(\"modal-dialog\" + (ctx._config.modalClass ? \" \" + ctx._config.modalClass : \"\"));\n      }\n    },\n    directives: [ɵngcc5.CdkPortalOutlet],\n    encapsulation: 2\n  });\n  return MdbModalContainerComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable: no-inferrable-types\n\n\nclass MdbModalConfig {\n  constructor() {\n    this.animation = true;\n    this.backdrop = true;\n    this.ignoreBackdropClick = false;\n    this.keyboard = true;\n    this.modalClass = '';\n    this.containerClass = '';\n    this.data = null;\n  }\n\n}\n\nclass MdbModalRef {\n  constructor(_overlayRef, _container) {\n    this._overlayRef = _overlayRef;\n    this._container = _container;\n    this.onClose$ = new Subject();\n    this.onClose = this.onClose$.asObservable();\n  }\n\n  close(message) {\n    this._container._close();\n\n    setTimeout(() => {\n      this._container._restoreScrollbar();\n\n      this.onClose$.next(message);\n      this.onClose$.complete();\n\n      this._overlayRef.detach();\n\n      this._overlayRef.dispose();\n    }, this._container.MODAL_TRANSITION);\n  }\n\n}\n\nlet MdbModalService = /*#__PURE__*/(() => {\n  class MdbModalService {\n    constructor(_document, _overlay, _injector, _cfr) {\n      this._document = _document;\n      this._overlay = _overlay;\n      this._injector = _injector;\n      this._cfr = _cfr;\n    }\n\n    open(componentOrTemplateRef, config) {\n      const defaultConfig = new MdbModalConfig();\n      config = config ? Object.assign(defaultConfig, config) : defaultConfig;\n\n      const overlayRef = this._createOverlay(config);\n\n      const container = this._createContainer(overlayRef, config);\n\n      const modalRef = this._createContent(componentOrTemplateRef, container, overlayRef, config);\n\n      this._registerListeners(modalRef, config, container);\n\n      return modalRef;\n    }\n\n    _createOverlay(config) {\n      const overlayConfig = this._getOverlayConfig(config);\n\n      return this._overlay.create(overlayConfig);\n    }\n\n    _getOverlayConfig(modalConfig) {\n      const config = new OverlayConfig({\n        positionStrategy: this._overlay.position().global(),\n        scrollStrategy: this._overlay.scrollStrategies.noop(),\n        hasBackdrop: modalConfig.backdrop,\n        backdropClass: 'mdb-backdrop'\n      });\n      return config;\n    }\n\n    _createContainer(overlayRef, config) {\n      const portal = new ComponentPortal(MdbModalContainerComponent, null, this._injector, this._cfr);\n      const containerRef = overlayRef.attach(portal);\n      containerRef.instance._config = config;\n      return containerRef.instance;\n    }\n\n    _createContent(componentOrTemplate, container, overlayRef, config) {\n      const modalRef = new MdbModalRef(overlayRef, container);\n\n      if (componentOrTemplate instanceof TemplateRef) {\n        container.attachTemplatePortal(new TemplatePortal(componentOrTemplate, null, {\n          $implicit: config.data,\n          modalRef\n        }));\n      } else {\n        const injector = this._createInjector(config, modalRef, container);\n\n        const contentRef = container.attachComponentPortal(new ComponentPortal(componentOrTemplate, config.viewContainerRef, injector));\n\n        if (config.data) {\n          Object.assign(contentRef.instance, Object.assign({}, config.data));\n        }\n      }\n\n      return modalRef;\n    }\n\n    _createInjector(config, modalRef, container) {\n      const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector; // The dialog container should be provided as the dialog container and the dialog's\n      // content are created out of the same `ViewContainerRef` and as such, are siblings\n      // for injector purposes. To allow the hierarchy that is expected, the dialog\n      // container is explicitly provided in the injector.\n\n      const providers = [{\n        provide: MdbModalContainerComponent,\n        useValue: container\n      }, {\n        provide: MdbModalRef,\n        useValue: modalRef\n      }];\n      return Injector.create({\n        parent: userInjector || this._injector,\n        providers\n      });\n    }\n\n    _registerListeners(modalRef, config, container) {\n      container.backdropClick$.pipe(take(1)).subscribe(() => {\n        modalRef.close();\n      });\n\n      if (config.keyboard) {\n        fromEvent(container._elementRef.nativeElement, 'keydown').pipe(filter(event => {\n          return event.key === 'Escape';\n        }), take(1)).subscribe(() => {\n          modalRef.close();\n        });\n      }\n    }\n\n  }\n\n  MdbModalService.ɵfac = function MdbModalService_Factory(t) {\n    return new (t || MdbModalService)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(ɵngcc2.Overlay), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver));\n  };\n\n  MdbModalService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MdbModalService,\n    factory: MdbModalService.ɵfac\n  });\n  return MdbModalService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbModalModule = /*#__PURE__*/(() => {\n  class MdbModalModule {}\n\n  MdbModalModule.ɵfac = function MdbModalModule_Factory(t) {\n    return new (t || MdbModalModule)();\n  };\n\n  MdbModalModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdbModalModule\n  });\n  MdbModalModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [MdbModalService],\n    imports: [[OverlayModule, PortalModule]]\n  });\n  return MdbModalModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbModalModule, {\n    declarations: function () {\n      return [MdbModalContainerComponent];\n    },\n    imports: function () {\n      return [OverlayModule, PortalModule];\n    },\n    exports: function () {\n      return [MdbModalContainerComponent];\n    }\n  });\n})(); // tslint:disable-next-line:component-class-suffix\n\n\nlet MdbDropdownToggleDirective = /*#__PURE__*/(() => {\n  class MdbDropdownToggleDirective {\n    constructor() {}\n\n    ngOnInit() {}\n\n  }\n\n  MdbDropdownToggleDirective.ɵfac = function MdbDropdownToggleDirective_Factory(t) {\n    return new (t || MdbDropdownToggleDirective)();\n  };\n\n  MdbDropdownToggleDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbDropdownToggleDirective,\n    selectors: [[\"\", \"mdbDropdownToggle\", \"\"]],\n    exportAs: [\"mdbDropdownToggle\"]\n  });\n  return MdbDropdownToggleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable-next-line:component-class-suffix\n\n\nlet MdbDropdownMenuDirective = /*#__PURE__*/(() => {\n  class MdbDropdownMenuDirective {\n    constructor() {}\n\n    ngOnInit() {}\n\n  }\n\n  MdbDropdownMenuDirective.ɵfac = function MdbDropdownMenuDirective_Factory(t) {\n    return new (t || MdbDropdownMenuDirective)();\n  };\n\n  MdbDropdownMenuDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbDropdownMenuDirective,\n    selectors: [[\"\", \"mdbDropdownMenu\", \"\"]],\n    exportAs: [\"mdbDropdownMenu\"]\n  });\n  return MdbDropdownMenuDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable-next-line:component-class-suffix\n\n\nlet MdbDropdownDirective = /*#__PURE__*/(() => {\n  class MdbDropdownDirective {\n    constructor(_overlay, _overlayPositionBuilder, _elementRef, _vcr, _breakpointObserver, _cdRef) {\n      this._overlay = _overlay;\n      this._overlayPositionBuilder = _overlayPositionBuilder;\n      this._elementRef = _elementRef;\n      this._vcr = _vcr;\n      this._breakpointObserver = _breakpointObserver;\n      this._cdRef = _cdRef;\n      this.animation = true;\n      this.offset = 0;\n      this.dropdownShow = new EventEmitter();\n      this.dropdownShown = new EventEmitter();\n      this.dropdownHide = new EventEmitter();\n      this.dropdownHidden = new EventEmitter();\n      this._open = false;\n      this._breakpoints = {\n        isSm: this._breakpointObserver.isMatched('(min-width: 576px)'),\n        isMd: this._breakpointObserver.isMatched('(min-width: 768px)'),\n        isLg: this._breakpointObserver.isMatched('(min-width: 992px)'),\n        isXl: this._breakpointObserver.isMatched('(min-width: 1200px)'),\n        isXxl: this._breakpointObserver.isMatched('(min-width: 1400px)')\n      };\n      this._destroy$ = new Subject();\n      this._animationState = 'hidden';\n    }\n\n    ngOnInit() {}\n\n    ngAfterContentInit() {\n      this._bindDropdownToggleClick();\n    }\n\n    ngOnDestroy() {\n      this._destroy$.next();\n\n      this._destroy$.complete();\n    }\n\n    _bindDropdownToggleClick() {\n      fromEvent(this._dropdownToggle.nativeElement, 'click').pipe(takeUntil(this._destroy$)).subscribe(() => this.toggle());\n    }\n\n    _createOverlayConfig() {\n      return new OverlayConfig({\n        hasBackdrop: false,\n        scrollStrategy: this._overlay.scrollStrategies.reposition(),\n        positionStrategy: this._createPositionStrategy()\n      });\n    }\n\n    _createOverlay() {\n      this._overlayRef = this._overlay.create(this._createOverlayConfig());\n    }\n\n    _createPositionStrategy() {\n      const positionStrategy = this._overlayPositionBuilder.flexibleConnectedTo(this._dropdownToggle).withPositions(this._getPosition()).withFlexibleDimensions(false);\n\n      return positionStrategy;\n    }\n\n    _getPosition() {\n      this._isDropUp = this._elementRef.nativeElement.classList.contains('dropup');\n      this._isDropStart = this._elementRef.nativeElement.classList.contains('dropstart');\n      this._isDropEnd = this._elementRef.nativeElement.classList.contains('dropend');\n      this._isDropdownMenuEnd = this._dropdownMenu.nativeElement.classList.contains('dropdown-menu-end');\n      this._xPosition = this._isDropdownMenuEnd ? 'end' : 'start';\n      const regex = new RegExp(/dropdown-menu-(sm|md|lg|xl|xxl)-(start|end)/, 'g');\n\n      const responsiveClass = this._dropdownMenu.nativeElement.className.match(regex);\n\n      if (responsiveClass) {\n        this._subscribeBrakpoints();\n\n        const positionRegex = new RegExp(/start|end/, 'g');\n        const breakpointRegex = new RegExp(/(sm|md|lg|xl|xxl)/, 'g');\n        const dropdownPosition = positionRegex.exec(responsiveClass)[0];\n        const breakpoint = breakpointRegex.exec(responsiveClass)[0];\n\n        switch (true) {\n          case breakpoint === 'xxl' && this._breakpoints.isXxl:\n            this._xPosition = dropdownPosition;\n            break;\n\n          case breakpoint === 'xl' && this._breakpoints.isXl:\n            this._xPosition = dropdownPosition;\n            break;\n\n          case breakpoint === 'lg' && this._breakpoints.isLg:\n            this._xPosition = dropdownPosition;\n            break;\n\n          case breakpoint === 'md' && this._breakpoints.isMd:\n            this._xPosition = dropdownPosition;\n            break;\n\n          case breakpoint === 'sm' && this._breakpoints.isSm:\n            this._xPosition = dropdownPosition;\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      let position;\n      const positionDropup = {\n        originX: this._xPosition,\n        originY: 'top',\n        overlayX: this._xPosition,\n        overlayY: 'bottom',\n        offsetY: -this.offset\n      };\n      const positionDropdown = {\n        originX: this._xPosition,\n        originY: 'bottom',\n        overlayX: this._xPosition,\n        overlayY: 'top',\n        offsetY: this.offset\n      };\n      const positionDropstart = {\n        originX: 'start',\n        originY: 'top',\n        overlayX: 'end',\n        overlayY: 'top',\n        offsetX: this.offset\n      };\n      const positionDropend = {\n        originX: 'end',\n        originY: 'top',\n        overlayX: 'start',\n        overlayY: 'top',\n        offsetX: -this.offset\n      };\n\n      switch (true) {\n        case this._isDropEnd:\n          position = [positionDropend, positionDropstart];\n          break;\n\n        case this._isDropStart:\n          position = [positionDropstart, positionDropend];\n          break;\n\n        case this._isDropUp:\n          position = [positionDropup, positionDropdown];\n          break;\n\n        default:\n          position = [positionDropdown, positionDropup];\n          break;\n      }\n\n      return position;\n    }\n\n    _listenToOutSideCick(overlayRef, origin) {\n      return fromEvent(document, 'click').pipe(filter(event => {\n        const target = event.target;\n        const notOrigin = target !== origin;\n        const notValue = !this._dropdownMenu.nativeElement.contains(target);\n        const notOverlay = !!overlayRef && overlayRef.overlayElement.contains(target) === false;\n        return notOrigin && notValue && notOverlay;\n      }), takeUntil(overlayRef.detachments()));\n    }\n\n    onAnimationEnd(event) {\n      if (event.fromState === 'visible' && event.toState === 'hidden') {\n        this._overlayRef.detach();\n\n        this._open = false;\n        this.dropdownHidden.emit(this);\n      }\n\n      if (event.fromState === 'hidden' && event.toState === 'visible') {\n        this.dropdownShown.emit(this);\n      }\n    }\n\n    _subscribeBrakpoints() {\n      const brakpoints = ['(min-width: 576px)', '(min-width: 768px)', '(min-width: 992px)', '(min-width: 1200px)', '(min-width: 1400px)'];\n      this._breakpointSubscription = this._breakpointObserver.observe(brakpoints).pipe(takeUntil(this._destroy$)).subscribe(result => {\n        Object.keys(this._breakpoints).forEach((key, index) => {\n          const brakpointValue = brakpoints[index];\n          const newBreakpoint = result.breakpoints[brakpointValue];\n          const isBreakpointChanged = newBreakpoint !== this._breakpoints[key];\n\n          if (!isBreakpointChanged) {\n            return;\n          }\n\n          this._breakpoints[key] = newBreakpoint;\n\n          if (this._open) {\n            this._overlayRef.updatePositionStrategy(this._createPositionStrategy());\n          }\n        });\n      });\n    }\n\n    show() {\n      this._cdRef.markForCheck();\n\n      if (this._open) {\n        return;\n      }\n\n      if (!this._overlayRef) {\n        this._createOverlay();\n      }\n\n      this._portal = new TemplatePortal(this._template, this._vcr);\n      this.dropdownShow.emit(this);\n      this._open = true;\n\n      this._overlayRef.attach(this._portal);\n\n      this._listenToOutSideCick(this._overlayRef, this._dropdownToggle.nativeElement).subscribe(() => this.hide());\n\n      this._animationState = 'visible';\n    }\n\n    hide() {\n      this._cdRef.markForCheck();\n\n      if (!this._open) {\n        return;\n      }\n\n      this.dropdownHide.emit(this);\n      this._animationState = 'hidden';\n    }\n\n    toggle() {\n      this._cdRef.markForCheck();\n\n      if (this._open) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    }\n\n  }\n\n  MdbDropdownDirective.ɵfac = function MdbDropdownDirective_Factory(t) {\n    return new (t || MdbDropdownDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.OverlayPositionBuilder), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc6.BreakpointObserver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  MdbDropdownDirective.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdbDropdownDirective,\n    selectors: [[\"\", \"mdbDropdown\", \"\"]],\n    contentQueries: function MdbDropdownDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdbDropdownToggleDirective, 5, ElementRef);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdbDropdownMenuDirective, 5, ElementRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._dropdownToggle = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._dropdownMenu = _t.first);\n      }\n    },\n    viewQuery: function MdbDropdownDirective_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c4, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._template = _t.first);\n      }\n    },\n    inputs: {\n      animation: \"animation\",\n      offset: \"offset\"\n    },\n    outputs: {\n      dropdownShow: \"dropdownShow\",\n      dropdownShown: \"dropdownShown\",\n      dropdownHide: \"dropdownHide\",\n      dropdownHidden: \"dropdownHidden\"\n    },\n    attrs: _c5,\n    ngContentSelectors: _c7,\n    decls: 4,\n    vars: 0,\n    consts: [[\"dropdownTemplate\", \"\"]],\n    template: function MdbDropdownDirective_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef(_c6);\n        ɵngcc0.ɵɵprojection(0);\n        ɵngcc0.ɵɵprojection(1, 1);\n        ɵngcc0.ɵɵtemplate(2, MdbDropdownDirective_ng_template_2_Template, 2, 2, \"ng-template\", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);\n      }\n    },\n    encapsulation: 2,\n    data: {\n      animation: [trigger('fade', [state('visible', style({\n        opacity: 1\n      })), state('hidden', style({\n        opacity: 0\n      })), transition('visible => hidden', animate('150ms linear')), transition('hidden => visible', [style({\n        opacity: 0\n      }), animate('150ms linear')])])]\n    },\n    changeDetection: 0\n  });\n  return MdbDropdownDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbDropdownModule = /*#__PURE__*/(() => {\n  class MdbDropdownModule {}\n\n  MdbDropdownModule.ɵfac = function MdbDropdownModule_Factory(t) {\n    return new (t || MdbDropdownModule)();\n  };\n\n  MdbDropdownModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdbDropdownModule\n  });\n  MdbDropdownModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, OverlayModule]]\n  });\n  return MdbDropdownModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbDropdownModule, {\n    declarations: function () {\n      return [MdbDropdownDirective, MdbDropdownToggleDirective, MdbDropdownMenuDirective];\n    },\n    imports: function () {\n      return [CommonModule, OverlayModule];\n    },\n    exports: function () {\n      return [MdbDropdownDirective, MdbDropdownToggleDirective, MdbDropdownMenuDirective];\n    }\n  });\n})();\n\nconst TRANSITION_BREAK_OPACITY = 0.5;\nconst GRADIENT = 'rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%';\nconst DEFAULT_RIPPLE_COLOR = [0, 0, 0];\nconst BOOTSTRAP_COLORS = ['primary', 'secondary', 'success', 'danger', 'warning', 'info', 'light', 'dark'];\nlet MdbRippleDirective = /*#__PURE__*/(() => {\n  class MdbRippleDirective {\n    constructor(_elementRef, _renderer) {\n      this._elementRef = _elementRef;\n      this._renderer = _renderer;\n      this.rippleCentered = false;\n      this.rippleColor = '';\n      this.rippleDuration = '500ms';\n      this.rippleRadius = 0;\n      this.rippleUnbound = false;\n      this.ripple = true;\n    }\n\n    get host() {\n      return this._elementRef.nativeElement;\n    }\n\n    _createRipple(event) {\n      const {\n        layerX,\n        layerY\n      } = event;\n      const offsetX = layerX;\n      const offsetY = layerY;\n      const height = this.host.offsetHeight;\n      const width = this.host.offsetWidth;\n\n      const duration = this._durationToMsNumber(this.rippleDuration);\n\n      const diameterOptions = {\n        offsetX: this.rippleCentered ? height / 2 : offsetX,\n        offsetY: this.rippleCentered ? width / 2 : offsetY,\n        height,\n        width\n      };\n\n      const diameter = this._getDiameter(diameterOptions);\n\n      const radiusValue = this.rippleRadius || diameter / 2;\n      const opacity = {\n        delay: duration * TRANSITION_BREAK_OPACITY,\n        duration: duration - duration * TRANSITION_BREAK_OPACITY\n      };\n      const styles = {\n        left: this.rippleCentered ? `${width / 2 - radiusValue}px` : `${offsetX - radiusValue}px`,\n        top: this.rippleCentered ? `${height / 2 - radiusValue}px` : `${offsetY - radiusValue}px`,\n        height: `${this.rippleRadius * 2 || diameter}px`,\n        width: `${this.rippleRadius * 2 || diameter}px`,\n        transitionDelay: `0s, ${opacity.delay}ms`,\n        transitionDuration: `${duration}ms, ${opacity.duration}ms`\n      };\n\n      const rippleHTML = this._renderer.createElement('div');\n\n      this._createHTMLRipple(this.host, rippleHTML, styles);\n\n      this._removeHTMLRipple(rippleHTML, duration);\n    }\n\n    _createHTMLRipple(wrapper, ripple, styles) {\n      Object.keys(styles).forEach(property => ripple.style[property] = styles[property]);\n\n      this._renderer.addClass(ripple, 'ripple-wave');\n\n      if (this.rippleColor !== '') {\n        this._removeOldColorClasses(wrapper);\n\n        this._addColor(ripple, wrapper);\n      }\n\n      this._toggleUnbound(wrapper);\n\n      this._appendRipple(ripple, wrapper);\n    }\n\n    _removeHTMLRipple(ripple, duration) {\n      setTimeout(() => {\n        if (ripple) {\n          ripple.remove();\n        }\n      }, duration);\n    }\n\n    _durationToMsNumber(time) {\n      return Number(time.replace('ms', '').replace('s', '000'));\n    }\n\n    _getDiameter({\n      offsetX,\n      offsetY,\n      height,\n      width\n    }) {\n      const top = offsetY <= height / 2;\n      const left = offsetX <= width / 2;\n\n      const pythagorean = (sideA, sideB) => Math.sqrt(Math.pow(sideA, 2) + Math.pow(sideB, 2));\n\n      const positionCenter = offsetY === height / 2 && offsetX === width / 2; // mouse position on the quadrants of the coordinate system\n\n      const quadrant = {\n        first: top === true && left === false,\n        second: top === true && left === true,\n        third: top === false && left === true,\n        fourth: top === false && left === false\n      };\n      const getCorner = {\n        topLeft: pythagorean(offsetX, offsetY),\n        topRight: pythagorean(width - offsetX, offsetY),\n        bottomLeft: pythagorean(offsetX, height - offsetY),\n        bottomRight: pythagorean(width - offsetX, height - offsetY)\n      };\n      let diameter = 0;\n\n      if (positionCenter || quadrant.fourth) {\n        diameter = getCorner.topLeft;\n      } else if (quadrant.third) {\n        diameter = getCorner.topRight;\n      } else if (quadrant.second) {\n        diameter = getCorner.bottomRight;\n      } else if (quadrant.first) {\n        diameter = getCorner.bottomLeft;\n      }\n\n      return diameter * 2;\n    }\n\n    _appendRipple(target, parent) {\n      const FIX_ADD_RIPPLE_EFFECT = 50; // delay for active animations\n\n      this._renderer.appendChild(parent, target);\n\n      setTimeout(() => {\n        this._renderer.addClass(target, 'active');\n      }, FIX_ADD_RIPPLE_EFFECT);\n    }\n\n    _toggleUnbound(target) {\n      if (this.rippleUnbound) {\n        this._renderer.addClass(target, 'ripple-surface-unbound');\n      } else {\n        this._renderer.removeClass(target, 'ripple-surface-unbound');\n      }\n    }\n\n    _addColor(target, parent) {\n      const isBootstrapColor = BOOTSTRAP_COLORS.find(color => color === this.rippleColor.toLowerCase());\n\n      if (isBootstrapColor) {\n        this._renderer.addClass(parent, `${'ripple-surface'}-${this.rippleColor.toLowerCase()}`);\n      } else {\n        const rgbValue = this._colorToRGB(this.rippleColor).join(',');\n\n        const gradientImage = GRADIENT.split('{{color}}').join(`${rgbValue}`);\n        target.style.backgroundImage = `radial-gradient(circle, ${gradientImage})`;\n      }\n    }\n\n    _removeOldColorClasses(target) {\n      const REGEXP_CLASS_COLOR = new RegExp(`${'ripple-surface'}-[a-z]+`, 'gi');\n      const PARENT_CLASSS_COLOR = target.classList.value.match(REGEXP_CLASS_COLOR) || [];\n      PARENT_CLASSS_COLOR.forEach(className => {\n        this._renderer.removeClass(target, className);\n      });\n    }\n\n    _colorToRGB(color) {\n      // tslint:disable-next-line: no-shadowed-variable\n      function hexToRgb(color) {\n        const HEX_COLOR_LENGTH = 7;\n        const IS_SHORT_HEX = color.length < HEX_COLOR_LENGTH;\n\n        if (IS_SHORT_HEX) {\n          color = `#${color[1]}${color[1]}${color[2]}${color[2]}${color[3]}${color[3]}`;\n        }\n\n        return [parseInt(color.substr(1, 2), 16), parseInt(color.substr(3, 2), 16), parseInt(color.substr(5, 2), 16)];\n      } // tslint:disable-next-line: no-shadowed-variable\n\n\n      function namedColorsToRgba(color) {\n        const tempElem = document.body.appendChild(document.createElement('fictum'));\n        const flag = 'rgb(1, 2, 3)';\n        tempElem.style.color = flag;\n\n        if (tempElem.style.color !== flag) {\n          return DEFAULT_RIPPLE_COLOR;\n        }\n\n        tempElem.style.color = color;\n\n        if (tempElem.style.color === flag || tempElem.style.color === '') {\n          return DEFAULT_RIPPLE_COLOR;\n        } // color parse failed\n\n\n        color = getComputedStyle(tempElem).color;\n        document.body.removeChild(tempElem);\n        return color;\n      } // tslint:disable-next-line: no-shadowed-variable\n\n\n      function rgbaToRgb(color) {\n        color = color.match(/[.\\d]+/g).map(a => +Number(a));\n        color.length = 3;\n        return color;\n      }\n\n      if (color.toLowerCase() === 'transparent') {\n        return DEFAULT_RIPPLE_COLOR;\n      }\n\n      if (color[0] === '#') {\n        return hexToRgb(color);\n      }\n\n      if (color.indexOf('rgb') === -1) {\n        color = namedColorsToRgba(color);\n      }\n\n      if (color.indexOf('rgb') === 0) {\n        return rgbaToRgb(color);\n      }\n\n      return DEFAULT_RIPPLE_COLOR;\n    }\n\n  }\n\n  MdbRippleDirective.ɵfac = function MdbRippleDirective_Factory(t) {\n    return new (t || MdbRippleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  MdbRippleDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbRippleDirective,\n    selectors: [[\"\", \"mdbRipple\", \"\"]],\n    hostVars: 2,\n    hostBindings: function MdbRippleDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function MdbRippleDirective_click_HostBindingHandler($event) {\n          return ctx._createRipple($event);\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"ripple-surface\", ctx.ripple);\n      }\n    },\n    inputs: {\n      rippleCentered: \"rippleCentered\",\n      rippleColor: \"rippleColor\",\n      rippleDuration: \"rippleDuration\",\n      rippleRadius: \"rippleRadius\",\n      rippleUnbound: \"rippleUnbound\"\n    },\n    exportAs: [\"mdbRipple\"]\n  });\n  return MdbRippleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbRippleModule = /*#__PURE__*/(() => {\n  class MdbRippleModule {}\n\n  MdbRippleModule.ɵfac = function MdbRippleModule_Factory(t) {\n    return new (t || MdbRippleModule)();\n  };\n\n  MdbRippleModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdbRippleModule\n  });\n  MdbRippleModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[]]\n  });\n  return MdbRippleModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbRippleModule, {\n    declarations: [MdbRippleDirective],\n    exports: [MdbRippleDirective]\n  });\n})();\n\nlet defaultIdNumber = 0; // tslint:disable-next-line:component-class-suffix\n\nlet MdbErrorDirective = /*#__PURE__*/(() => {\n  class MdbErrorDirective {\n    constructor(_elementRef, renderer) {\n      this._elementRef = _elementRef;\n      this.renderer = renderer;\n      this.id = `mdb-error-${defaultIdNumber++}`;\n      this.errorMsg = true;\n      this.messageId = this.id;\n      this._destroy$ = new Subject();\n    }\n\n    _getClosestEl(el, selector) {\n      for (; el && el !== document; el = el.parentNode) {\n        if (el.matches && el.matches(selector)) {\n          return el;\n        }\n      }\n\n      return null;\n    }\n\n    ngOnInit() {\n      const textarea = this._getClosestEl(this._elementRef.nativeElement, 'textarea');\n\n      if (textarea) {\n        let height = textarea.offsetHeight + 4 + 'px';\n        this.renderer.setStyle(this._elementRef.nativeElement, 'top', height);\n        fromEvent(textarea, 'keyup').pipe(takeUntil(this._destroy$)).subscribe(() => {\n          height = textarea.offsetHeight + 4 + 'px';\n          this.renderer.setStyle(this._elementRef.nativeElement, 'top', height);\n        });\n      }\n    }\n\n    ngOnDestroy() {\n      this._destroy$.next();\n\n      this._destroy$.complete();\n    }\n\n  }\n\n  MdbErrorDirective.ɵfac = function MdbErrorDirective_Factory(t) {\n    return new (t || MdbErrorDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  MdbErrorDirective.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdbErrorDirective,\n    selectors: [[\"mdb-error\"]],\n    hostVars: 3,\n    hostBindings: function MdbErrorDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"id\", ctx.messageId);\n        ɵngcc0.ɵɵclassProp(\"error-message\", ctx.errorMsg);\n      }\n    },\n    inputs: {\n      id: \"id\"\n    },\n    ngContentSelectors: _c2,\n    decls: 1,\n    vars: 0,\n    template: function MdbErrorDirective_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return MdbErrorDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet defaultIdNumber$1 = 0; // tslint:disable-next-line:component-class-suffix\n\nlet MdbSuccessDirective = /*#__PURE__*/(() => {\n  class MdbSuccessDirective {\n    constructor(_elementRef, renderer) {\n      this._elementRef = _elementRef;\n      this.renderer = renderer;\n      this.id = `mdb-success-${defaultIdNumber$1++}`;\n      this.successMsg = true;\n      this.messageId = this.id;\n      this._destroy$ = new Subject();\n    }\n\n    _getClosestEl(el, selector) {\n      for (; el && el !== document; el = el.parentNode) {\n        if (el.matches && el.matches(selector)) {\n          return el;\n        }\n      }\n\n      return null;\n    }\n\n    ngOnInit() {\n      const textarea = this._getClosestEl(this._elementRef.nativeElement, 'textarea');\n\n      if (textarea) {\n        let height = textarea.offsetHeight + 4 + 'px';\n        this.renderer.setStyle(this._elementRef.nativeElement, 'top', height);\n        fromEvent(textarea, 'keyup').pipe(takeUntil(this._destroy$)).subscribe(() => {\n          height = textarea.offsetHeight + 4 + 'px';\n          this.renderer.setStyle(this._elementRef.nativeElement, 'top', height);\n        });\n      }\n    }\n\n    ngOnDestroy() {\n      this._destroy$.next();\n\n      this._destroy$.complete();\n    }\n\n  }\n\n  MdbSuccessDirective.ɵfac = function MdbSuccessDirective_Factory(t) {\n    return new (t || MdbSuccessDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2));\n  };\n\n  MdbSuccessDirective.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdbSuccessDirective,\n    selectors: [[\"mdb-success\"]],\n    hostVars: 3,\n    hostBindings: function MdbSuccessDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"id\", ctx.messageId);\n        ɵngcc0.ɵɵclassProp(\"success-message\", ctx.successMsg);\n      }\n    },\n    inputs: {\n      id: \"id\"\n    },\n    ngContentSelectors: _c2,\n    decls: 1,\n    vars: 0,\n    template: function MdbSuccessDirective_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return MdbSuccessDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbValidateDirective = /*#__PURE__*/(() => {\n  class MdbValidateDirective {\n    constructor(renderer, _elementRef) {\n      this.renderer = renderer;\n      this._elementRef = _elementRef;\n      this._validate = true;\n      this._validateSuccess = true;\n      this._validateError = true;\n    }\n\n    get validate() {\n      return this._validate;\n    }\n\n    set validate(value) {\n      this._validate = value;\n      this.updateErrorClass();\n      this.updateSuccessClass();\n    }\n\n    get validateSuccess() {\n      return this._validateSuccess;\n    }\n\n    set validateSuccess(value) {\n      this._validateSuccess = value;\n      this.updateSuccessClass();\n    }\n\n    get validateError() {\n      return this._validateError;\n    }\n\n    set validateError(value) {\n      this._validateError = value;\n      this.updateErrorClass();\n      this.updateSuccessClass();\n    }\n\n    updateSuccessClass() {\n      if (this.validate && this.validateSuccess) {\n        this.renderer.addClass(this._elementRef.nativeElement, 'validate-success');\n      } else {\n        this.renderer.removeClass(this._elementRef.nativeElement, 'validate-success');\n      }\n    }\n\n    updateErrorClass() {\n      if (this.validate && this.validateError) {\n        this.renderer.addClass(this._elementRef.nativeElement, 'validate-error');\n      } else {\n        this.renderer.removeClass(this._elementRef.nativeElement, 'validate-error');\n      }\n    }\n\n    ngOnInit() {\n      this.updateSuccessClass();\n      this.updateErrorClass();\n    }\n\n  }\n\n  MdbValidateDirective.ɵfac = function MdbValidateDirective_Factory(t) {\n    return new (t || MdbValidateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdbValidateDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbValidateDirective,\n    selectors: [[\"\", \"mdbValidate\", \"\"]],\n    inputs: {\n      validate: \"validate\",\n      validateSuccess: \"validateSuccess\",\n      validateError: \"validateError\",\n      mdbValidate: \"mdbValidate\"\n    }\n  });\n  return MdbValidateDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbValidationModule = /*#__PURE__*/(() => {\n  class MdbValidationModule {}\n\n  MdbValidationModule.ɵfac = function MdbValidationModule_Factory(t) {\n    return new (t || MdbValidationModule)();\n  };\n\n  MdbValidationModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdbValidationModule\n  });\n  MdbValidationModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return MdbValidationModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbValidationModule, {\n    declarations: function () {\n      return [MdbErrorDirective, MdbSuccessDirective, MdbValidateDirective];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [MdbErrorDirective, MdbSuccessDirective, MdbValidateDirective];\n    }\n  });\n})();\n\nlet MdbScrollspyLinkDirective = /*#__PURE__*/(() => {\n  class MdbScrollspyLinkDirective {\n    constructor(cdRef, document) {\n      this.cdRef = cdRef;\n      this.document = document;\n      this._scrollIntoView = true;\n      this.scrollspyLink = true;\n      this.active = false;\n    }\n\n    get scrollIntoView() {\n      return this._scrollIntoView;\n    }\n\n    set scrollIntoView(value) {\n      this._scrollIntoView = value;\n    }\n\n    get section() {\n      return this._section;\n    }\n\n    set section(value) {\n      if (value) {\n        this._section = value;\n      }\n    }\n\n    get id() {\n      return this._id;\n    }\n\n    set id(newId) {\n      if (newId) {\n        this._id = newId;\n      }\n    }\n\n    onClick() {\n      if (this.section && this.scrollIntoView === true) {\n        this.section.scrollIntoView();\n      }\n    }\n\n    detectChanges() {\n      this.cdRef.detectChanges();\n    }\n\n    assignSectionToId() {\n      this.section = this.document.documentElement.querySelector(`#${this.id}`);\n    }\n\n    ngOnInit() {\n      this.assignSectionToId();\n    }\n\n  }\n\n  MdbScrollspyLinkDirective.ɵfac = function MdbScrollspyLinkDirective_Factory(t) {\n    return new (t || MdbScrollspyLinkDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT));\n  };\n\n  MdbScrollspyLinkDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbScrollspyLinkDirective,\n    selectors: [[\"\", \"mdbScrollspyLink\", \"\"]],\n    hostVars: 4,\n    hostBindings: function MdbScrollspyLinkDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"click\", function MdbScrollspyLinkDirective_click_HostBindingHandler() {\n          return ctx.onClick();\n        });\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"scrollspy-link\", ctx.scrollspyLink)(\"active\", ctx.active);\n      }\n    },\n    inputs: {\n      scrollIntoView: \"scrollIntoView\",\n      id: [\"mdbScrollspyLink\", \"id\"]\n    }\n  });\n  return MdbScrollspyLinkDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbScrollspyService = /*#__PURE__*/(() => {\n  class MdbScrollspyService {\n    constructor() {\n      this.scrollSpys = [];\n      this.activeSubject = new Subject();\n      this.active$ = this.activeSubject;\n    }\n\n    addScrollspy(scrollSpy) {\n      this.scrollSpys.push(scrollSpy);\n    }\n\n    removeScrollspy(scrollSpyId) {\n      const scrollSpyIndex = this.scrollSpys.findIndex(spy => {\n        return spy.id === scrollSpyId;\n      });\n      this.scrollSpys.splice(scrollSpyIndex, 1);\n    }\n\n    updateActiveState(scrollSpyId, activeLinkId) {\n      const scrollSpy = this.scrollSpys.find(spy => {\n        return spy.id === scrollSpyId;\n      });\n\n      if (!scrollSpy) {\n        return;\n      }\n\n      const activeLink = scrollSpy.links.find(link => {\n        return link.id === activeLinkId;\n      });\n      this.setActiveLink(activeLink);\n    }\n\n    removeActiveState(scrollSpyId, activeLinkId) {\n      const scrollSpy = this.scrollSpys.find(spy => {\n        return spy.id === scrollSpyId;\n      });\n\n      if (!scrollSpy) {\n        return;\n      }\n\n      const activeLink = scrollSpy.links.find(link => {\n        return link.id === activeLinkId;\n      });\n\n      if (!activeLink) {\n        return;\n      }\n\n      activeLink.active = false;\n      activeLink.detectChanges();\n    }\n\n    setActiveLink(activeLink) {\n      if (activeLink) {\n        activeLink.active = true;\n        activeLink.detectChanges();\n        this.activeSubject.next(activeLink);\n      }\n    }\n\n    removeActiveLinks(scrollSpyId) {\n      const scrollSpy = this.scrollSpys.find(spy => {\n        return spy.id === scrollSpyId;\n      });\n\n      if (!scrollSpy) {\n        return;\n      }\n\n      scrollSpy.links.forEach(link => {\n        link.active = false;\n        link.detectChanges();\n      });\n    }\n\n  }\n\n  MdbScrollspyService.ɵfac = function MdbScrollspyService_Factory(t) {\n    return new (t || MdbScrollspyService)();\n  };\n\n  MdbScrollspyService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MdbScrollspyService,\n    factory: MdbScrollspyService.ɵfac\n  });\n  return MdbScrollspyService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable-next-line:component-class-suffix\n\n\nlet MdbScrollspyDirective = /*#__PURE__*/(() => {\n  class MdbScrollspyDirective {\n    constructor(scrollSpyService) {\n      this.scrollSpyService = scrollSpyService;\n      this._destroy$ = new Subject();\n      this.activeLinkChange = new EventEmitter();\n    }\n\n    get id() {\n      return this._id;\n    }\n\n    set id(newId) {\n      if (newId) {\n        this._id = newId;\n      }\n    }\n\n    ngOnInit() {\n      this.activeSub = this.scrollSpyService.active$.pipe(takeUntil(this._destroy$), distinctUntilChanged()).subscribe(activeLink => {\n        this.activeLinkChange.emit(activeLink);\n      });\n    }\n\n    ngAfterContentInit() {\n      this.scrollSpyService.addScrollspy({\n        id: this.id,\n        links: this.links\n      });\n    }\n\n    ngOnDestroy() {\n      this.scrollSpyService.removeScrollspy(this.id);\n\n      this._destroy$.next();\n\n      this._destroy$.complete();\n    }\n\n  }\n\n  MdbScrollspyDirective.ɵfac = function MdbScrollspyDirective_Factory(t) {\n    return new (t || MdbScrollspyDirective)(ɵngcc0.ɵɵdirectiveInject(MdbScrollspyService));\n  };\n\n  MdbScrollspyDirective.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdbScrollspyDirective,\n    selectors: [[\"\", \"mdbScrollspy\", \"\"]],\n    contentQueries: function MdbScrollspyDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdbScrollspyLinkDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.links = _t);\n      }\n    },\n    inputs: {\n      id: [\"mdbScrollspy\", \"id\"]\n    },\n    outputs: {\n      activeLinkChange: \"activeLinkChange\"\n    },\n    attrs: _c8,\n    ngContentSelectors: _c2,\n    decls: 1,\n    vars: 0,\n    template: function MdbScrollspyDirective_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return MdbScrollspyDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable-next-line: directive-class-suffix\n\n\nlet MdbScrollspyElementDirective = /*#__PURE__*/(() => {\n  class MdbScrollspyElementDirective {\n    constructor(_elementRef, renderer, ngZone, scrollSpyService) {\n      this._elementRef = _elementRef;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.scrollSpyService = scrollSpyService;\n      this.offset = 0;\n    }\n\n    get host() {\n      return this._elementRef.nativeElement;\n    }\n\n    get scrollSpyId() {\n      return this._scrollSpyId;\n    }\n\n    set scrollSpyId(newId) {\n      if (newId) {\n        this._scrollSpyId = newId;\n      }\n    }\n\n    isElementInViewport() {\n      const scrollTop = this.container.scrollTop;\n      const elTop = this.host.offsetTop - this.offset;\n      const elHeight = this.host.offsetHeight;\n      return scrollTop >= elTop && scrollTop < elTop + elHeight;\n    }\n\n    updateActiveState(scrollSpyId, id) {\n      if (this.isElementInViewport()) {\n        this.scrollSpyService.removeActiveLinks(scrollSpyId);\n        this.scrollSpyService.updateActiveState(scrollSpyId, id);\n      }\n    }\n\n    onScroll() {\n      this.updateActiveState(this.scrollSpyId, this.id);\n    }\n\n    listenToScroll() {\n      this.renderer.listen(this.container, 'scroll', () => {\n        this.onScroll();\n      });\n    }\n\n    ngOnInit() {\n      this.id = this.host.id;\n\n      if (!this.container) {\n        this.container = this._getClosestEl(this.host, '.scrollspy-container');\n      }\n\n      this.renderer.setStyle(this.container, 'position', 'relative');\n      this.ngZone.runOutsideAngular(this.listenToScroll.bind(this));\n    }\n\n    ngAfterViewInit() {\n      setTimeout(() => {\n        this.updateActiveState(this.scrollSpyId, this.id);\n      }, 0);\n    }\n\n    _getClosestEl(el, selector) {\n      for (; el && el !== document; el = el.parentNode) {\n        if (el.matches && el.matches(selector)) {\n          return el;\n        }\n      }\n\n      return null;\n    }\n\n  }\n\n  MdbScrollspyElementDirective.ɵfac = function MdbScrollspyElementDirective_Factory(t) {\n    return new (t || MdbScrollspyElementDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MdbScrollspyService));\n  };\n\n  MdbScrollspyElementDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbScrollspyElementDirective,\n    selectors: [[\"\", \"mdbScrollspyElement\", \"\"]],\n    inputs: {\n      offset: \"offset\",\n      scrollSpyId: [\"mdbScrollspyElement\", \"scrollSpyId\"],\n      container: \"container\"\n    }\n  });\n  return MdbScrollspyElementDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbScrollspyWindowDirective = /*#__PURE__*/(() => {\n  class MdbScrollspyWindowDirective {\n    constructor(document, el, renderer, ngZone, scrollSpyService) {\n      this.document = document;\n      this.el = el;\n      this.renderer = renderer;\n      this.ngZone = ngZone;\n      this.scrollSpyService = scrollSpyService;\n      this.offset = 0;\n    }\n\n    get scrollSpyId() {\n      return this._scrollSpyId;\n    }\n\n    set scrollSpyId(newId) {\n      if (newId) {\n        this._scrollSpyId = newId;\n      }\n    }\n\n    isElementInViewport() {\n      const scrollTop = this.document.documentElement.scrollTop || this.document.body.scrollTop;\n      const elHeight = this.el.nativeElement.offsetHeight;\n      const elTop = this.el.nativeElement.offsetTop - this.offset;\n      const elBottom = elTop + elHeight;\n      return scrollTop >= elTop && scrollTop <= elBottom;\n    }\n\n    updateActiveState(scrollSpyId, id) {\n      if (this.isElementInViewport()) {\n        this.scrollSpyService.updateActiveState(scrollSpyId, id);\n      } else {\n        this.scrollSpyService.removeActiveState(scrollSpyId, id);\n      }\n    }\n\n    onScroll() {\n      this.updateActiveState(this.scrollSpyId, this.id);\n    }\n\n    listenToScroll() {\n      this.renderer.listen(window, 'scroll', () => {\n        this.onScroll();\n      });\n    }\n\n    ngOnInit() {\n      this.id = this.el.nativeElement.id;\n      this.ngZone.runOutsideAngular(this.listenToScroll.bind(this));\n    }\n\n    ngAfterViewInit() {\n      setTimeout(() => {\n        this.updateActiveState(this.scrollSpyId, this.id);\n      }, 0);\n    }\n\n  }\n\n  MdbScrollspyWindowDirective.ɵfac = function MdbScrollspyWindowDirective_Factory(t) {\n    return new (t || MdbScrollspyWindowDirective)(ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MdbScrollspyService));\n  };\n\n  MdbScrollspyWindowDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbScrollspyWindowDirective,\n    selectors: [[\"\", \"mdbScrollspyWindow\", \"\"]],\n    inputs: {\n      offset: \"offset\",\n      scrollSpyId: [\"mdbScrollspyWindow\", \"scrollSpyId\"]\n    }\n  });\n  return MdbScrollspyWindowDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbScrollspyModule = /*#__PURE__*/(() => {\n  class MdbScrollspyModule {}\n\n  MdbScrollspyModule.ɵfac = function MdbScrollspyModule_Factory(t) {\n    return new (t || MdbScrollspyModule)();\n  };\n\n  MdbScrollspyModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdbScrollspyModule\n  });\n  MdbScrollspyModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [MdbScrollspyService]\n  });\n  return MdbScrollspyModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbScrollspyModule, {\n    declarations: [MdbScrollspyDirective, MdbScrollspyLinkDirective, MdbScrollspyElementDirective, MdbScrollspyWindowDirective],\n    exports: [MdbScrollspyDirective, MdbScrollspyLinkDirective, MdbScrollspyElementDirective, MdbScrollspyWindowDirective]\n  });\n})();\n\nconst RANGE_VALUE_ACCESOR = {\n  provide: NG_VALUE_ACCESSOR,\n  // tslint:disable-next-line: no-use-before-declare\n  useExisting: forwardRef(() => MdbRangeComponent),\n  multi: true\n};\nlet MdbRangeComponent = /*#__PURE__*/(() => {\n  class MdbRangeComponent {\n    constructor(_cdRef) {\n      this._cdRef = _cdRef;\n      this.min = 0;\n      this.max = 100;\n      this.rangeValueChange = new EventEmitter();\n      this.visibility = false; // Control Value Accessor Methods\n\n      this.onChange = _ => {};\n\n      this.onTouched = () => {};\n    }\n\n    onchange(event) {\n      this.onChange(event.target.value);\n    }\n\n    onInput() {\n      this.rangeValueChange.emit({\n        value: this.value\n      });\n      this.focusRangeInput();\n    }\n\n    ngAfterViewInit() {\n      this.thumbPositionUpdate();\n    }\n\n    focusRangeInput() {\n      this.input.nativeElement.focus();\n      this.visibility = true;\n    }\n\n    blurRangeInput() {\n      this.input.nativeElement.blur();\n      this.visibility = false;\n    }\n\n    thumbPositionUpdate() {\n      const rangeInput = this.input.nativeElement;\n      const inputValue = rangeInput.value;\n      const minValue = rangeInput.min ? rangeInput.min : 0;\n      const maxValue = rangeInput.max ? rangeInput.max : 100;\n      const newValue = Number((inputValue - minValue) * 100 / (maxValue - minValue));\n      this.value = inputValue;\n      this.thumbStyle = {\n        left: `calc(${newValue}% + (${8 - newValue * 0.15}px))`\n      };\n    }\n\n    writeValue(value) {\n      this.value = value;\n\n      this._cdRef.markForCheck();\n\n      setTimeout(() => {\n        this.thumbPositionUpdate();\n      }, 0);\n    }\n\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n\n  }\n\n  MdbRangeComponent.ɵfac = function MdbRangeComponent_Factory(t) {\n    return new (t || MdbRangeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  MdbRangeComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdbRangeComponent,\n    selectors: [[\"mdb-range\"]],\n    viewQuery: function MdbRangeComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c9, 5);\n        ɵngcc0.ɵɵviewQuery(_c10, 5);\n        ɵngcc0.ɵɵviewQuery(_c11, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.input = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.thumb = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.thumbValue = _t.first);\n      }\n    },\n    hostBindings: function MdbRangeComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"change\", function MdbRangeComponent_change_HostBindingHandler($event) {\n          return ctx.onchange($event);\n        })(\"input\", function MdbRangeComponent_input_HostBindingHandler() {\n          return ctx.onInput();\n        });\n      }\n    },\n    inputs: {\n      min: \"min\",\n      max: \"max\",\n      value: \"value\",\n      disabled: \"disabled\",\n      id: \"id\",\n      required: \"required\",\n      name: \"name\",\n      step: \"step\",\n      default: \"default\",\n      defaultRangeCounterClass: \"defaultRangeCounterClass\"\n    },\n    outputs: {\n      rangeValueChange: \"rangeValueChange\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([RANGE_VALUE_ACCESOR])],\n    decls: 10,\n    vars: 14,\n    consts: [[\"for\", \"customRange2\", 1, \"form-label\"], [1, \"range\"], [\"type\", \"range\", \"min\", \"0\", \"max\", \"5\", 1, \"form-range\", 3, \"name\", \"disabled\", \"id\", \"min\", \"max\", \"step\", \"value\", \"ngModel\", \"ngModelChange\", \"input\", \"blur\", \"mousedown\", \"mouseup\", \"touchstart\", \"touchend\"], [\"input\", \"\"], [1, \"thumb\", 3, \"ngStyle\", \"ngClass\"], [\"thumb\", \"\"], [1, \"thumb-value\"], [\"thumbValue\", \"\"]],\n    template: function MdbRangeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"label\", 0);\n        ɵngcc0.ɵɵtext(1, \"Example range\");\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(2, \"div\", 1)(3, \"input\", 2, 3);\n        ɵngcc0.ɵɵlistener(\"ngModelChange\", function MdbRangeComponent_Template_input_ngModelChange_3_listener($event) {\n          return ctx.value = $event;\n        })(\"input\", function MdbRangeComponent_Template_input_input_3_listener() {\n          return ctx.thumbPositionUpdate();\n        })(\"blur\", function MdbRangeComponent_Template_input_blur_3_listener() {\n          return ctx.blurRangeInput();\n        })(\"mousedown\", function MdbRangeComponent_Template_input_mousedown_3_listener() {\n          return ctx.focusRangeInput();\n        })(\"mouseup\", function MdbRangeComponent_Template_input_mouseup_3_listener() {\n          return ctx.blurRangeInput();\n        })(\"touchstart\", function MdbRangeComponent_Template_input_touchstart_3_listener() {\n          return ctx.focusRangeInput();\n        })(\"touchend\", function MdbRangeComponent_Template_input_touchend_3_listener() {\n          return ctx.blurRangeInput();\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(5, \"span\", 4, 5)(7, \"span\", 6, 7);\n        ɵngcc0.ɵɵtext(9);\n        ɵngcc0.ɵɵelementEnd()()();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"name\", ctx.name)(\"disabled\", ctx.disabled)(\"id\", ctx.id)(\"min\", ctx.min)(\"max\", ctx.max)(\"step\", ctx.step)(\"value\", ctx.value)(\"ngModel\", ctx.value)(\"id\", ctx.id);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngStyle\", ctx.thumbStyle)(\"ngClass\", ɵngcc0.ɵɵpureFunction1(12, _c12, ctx.visibility));\n        ɵngcc0.ɵɵadvance(4);\n        ɵngcc0.ɵɵtextInterpolate(ctx.value);\n      }\n    },\n    directives: [ɵngcc7.RangeValueAccessor, ɵngcc7.DefaultValueAccessor, ɵngcc7.NgControlStatus, ɵngcc7.NgModel, ɵngcc1.NgStyle, ɵngcc1.NgClass],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MdbRangeComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbRangeModule = /*#__PURE__*/(() => {\n  class MdbRangeModule {}\n\n  MdbRangeModule.ɵfac = function MdbRangeModule_Factory(t) {\n    return new (t || MdbRangeModule)();\n  };\n\n  MdbRangeModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdbRangeModule\n  });\n  MdbRangeModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, FormsModule]]\n  });\n  return MdbRangeModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbRangeModule, {\n    declarations: function () {\n      return [MdbRangeComponent];\n    },\n    imports: function () {\n      return [CommonModule, FormsModule];\n    },\n    exports: function () {\n      return [MdbRangeComponent];\n    }\n  });\n})();\n\nconst MDB_TAB_CONTENT = new InjectionToken('MdbTabContentDirective');\nlet MdbTabContentDirective = /*#__PURE__*/(() => {\n  class MdbTabContentDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  MdbTabContentDirective.ɵfac = function MdbTabContentDirective_Factory(t) {\n    return new (t || MdbTabContentDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n  };\n\n  MdbTabContentDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbTabContentDirective,\n    selectors: [[\"\", \"mdbTabContent\", \"\"]],\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: MDB_TAB_CONTENT,\n      useExisting: MdbTabContentDirective\n    }])]\n  });\n  return MdbTabContentDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst MDB_TAB_TITLE = new InjectionToken('MdbTabTitleDirective');\nlet MdbTabTitleDirective = /*#__PURE__*/(() => {\n  class MdbTabTitleDirective {\n    constructor(template) {\n      this.template = template;\n    }\n\n  }\n\n  MdbTabTitleDirective.ɵfac = function MdbTabTitleDirective_Factory(t) {\n    return new (t || MdbTabTitleDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef));\n  };\n\n  MdbTabTitleDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbTabTitleDirective,\n    selectors: [[\"\", \"mdbTabTitle\", \"\"]],\n    features: [ɵngcc0.ɵɵProvidersFeature([{\n      provide: MDB_TAB_TITLE,\n      useExisting: MdbTabTitleDirective\n    }])]\n  });\n  return MdbTabTitleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbTabComponent = /*#__PURE__*/(() => {\n  class MdbTabComponent {\n    constructor(_elementRef, _renderer, _vcr) {\n      this._elementRef = _elementRef;\n      this._renderer = _renderer;\n      this._vcr = _vcr;\n      this.activeStateChange$ = new Subject();\n      this.disabled = false;\n      this._contentPortal = null;\n      this._titlePortal = null;\n      this._active = false;\n    }\n\n    get active() {\n      return this._active;\n    }\n\n    get content() {\n      return this._contentPortal;\n    }\n\n    get titleContent() {\n      return this._titlePortal;\n    }\n\n    get shouldAttach() {\n      return this._lazyContent === undefined;\n    } // tslint:disable-next-line: adjacent-overload-signatures\n\n\n    set active(value) {\n      if (value) {\n        this._renderer.addClass(this._elementRef.nativeElement, 'show');\n\n        this._renderer.addClass(this._elementRef.nativeElement, 'active');\n      } else {\n        this._renderer.removeClass(this._elementRef.nativeElement, 'show');\n\n        this._renderer.removeClass(this._elementRef.nativeElement, 'active');\n      }\n\n      this._active = value;\n      this.activeStateChange$.next(value);\n    }\n\n    ngOnInit() {\n      this._createContentPortal();\n\n      if (this._titleContent) {\n        this._createTitlePortal();\n      }\n    }\n\n    _createContentPortal() {\n      const content = this._lazyContent || this._content;\n      this._contentPortal = new TemplatePortal(content, this._vcr);\n    }\n\n    _createTitlePortal() {\n      this._titlePortal = new TemplatePortal(this._titleContent, this._vcr);\n    }\n\n  }\n\n  MdbTabComponent.ɵfac = function MdbTabComponent_Factory(t) {\n    return new (t || MdbTabComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MdbTabComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdbTabComponent,\n    selectors: [[\"mdb-tab\"]],\n    contentQueries: function MdbTabComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MDB_TAB_CONTENT, 7, TemplateRef);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MDB_TAB_TITLE, 7, TemplateRef);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._lazyContent = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._titleContent = _t.first);\n      }\n    },\n    viewQuery: function MdbTabComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(TemplateRef, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._content = _t.first);\n      }\n    },\n    inputs: {\n      disabled: \"disabled\",\n      title: \"title\"\n    },\n    ngContentSelectors: _c2,\n    decls: 1,\n    vars: 0,\n    template: function MdbTabComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MdbTabComponent_ng_template_0_Template, 1, 0, \"ng-template\");\n      }\n    },\n    encapsulation: 2\n  });\n  return MdbTabComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass MdbTabChange {}\n\nlet MdbTabsComponent = /*#__PURE__*/(() => {\n  class MdbTabsComponent {\n    constructor() {\n      this._destroy$ = new Subject();\n      this.fill = false;\n      this.justified = false;\n      this.pills = false;\n      this.vertical = false;\n      this.activeTabChange = new EventEmitter();\n    }\n\n    ngAfterContentInit() {\n      const firstActiveTabIndex = this.tabs.toArray().findIndex(tab => !tab.disabled);\n      this.setActiveTab(firstActiveTabIndex); // tslint:disable-next-line: deprecation\n\n      this.tabs.changes.pipe(takeUntil(this._destroy$)).subscribe(() => {\n        const hasActiveTab = this.tabs.find(tab => tab.active);\n\n        if (!hasActiveTab) {\n          const closestTabIndex = this._getClosestTabIndex(this._selectedIndex);\n\n          if (closestTabIndex !== -1) {\n            this.setActiveTab(closestTabIndex);\n          }\n        }\n      });\n    }\n\n    setActiveTab(index) {\n      const activeTab = this.tabs.toArray()[index];\n\n      if (!activeTab || activeTab && activeTab.disabled) {\n        return;\n      }\n\n      this.tabs.forEach(tab => tab.active = tab === activeTab);\n      this._selectedIndex = index;\n\n      const tabChangeEvent = this._getTabChangeEvent(index, activeTab);\n\n      this.activeTabChange.emit(tabChangeEvent);\n    }\n\n    _getTabChangeEvent(index, tab) {\n      const event = new MdbTabChange();\n      event.index = index;\n      event.tab = tab;\n      return event;\n    }\n\n    _getClosestTabIndex(index) {\n      const tabs = this.tabs.toArray();\n      const tabsLength = tabs.length;\n\n      if (!tabsLength) {\n        return -1;\n      }\n\n      for (let i = 1; i <= tabsLength; i += 1) {\n        const prevIndex = index - i;\n        const nextIndex = index + i;\n\n        if (tabs[prevIndex] && !tabs[prevIndex].disabled) {\n          return prevIndex;\n        }\n\n        if (tabs[nextIndex] && !tabs[nextIndex].disabled) {\n          return nextIndex;\n        }\n      }\n\n      return -1;\n    }\n\n    ngOnDestroy() {\n      this._destroy$.next();\n\n      this._destroy$.complete();\n    }\n\n  }\n\n  MdbTabsComponent.ɵfac = function MdbTabsComponent_Factory(t) {\n    return new (t || MdbTabsComponent)();\n  };\n\n  MdbTabsComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdbTabsComponent,\n    selectors: [[\"mdb-tabs\"]],\n    contentQueries: function MdbTabsComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdbTabComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabs = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function MdbTabsComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"row\", ctx.vertical);\n      }\n    },\n    inputs: {\n      fill: \"fill\",\n      justified: \"justified\",\n      pills: \"pills\",\n      vertical: \"vertical\"\n    },\n    outputs: {\n      activeTabChange: \"activeTabChange\"\n    },\n    decls: 4,\n    vars: 14,\n    consts: [[\"role\", \"tablist\", 1, \"nav\", \"mb-3\", \"col-3\", \"flex-column\", 3, \"ngClass\"], [\"class\", \"nav-item\", \"role\", \"presentation\", 3, \"click\", 4, \"ngFor\", \"ngForOf\"], [1, \"tab-content\", 3, \"ngClass\"], [4, \"ngFor\", \"ngForOf\"], [\"role\", \"presentation\", 1, \"nav-item\", 3, \"click\"], [\"href\", \"javascript:void(0)\", \"role\", \"tab\", 1, \"nav-link\"], [3, \"ngIf\"], [3, \"cdkPortalOutlet\"], [1, \"tab-pane\", \"fade\", 3, \"ngClass\"], [\"mdbTabPortalOutlet\", \"\", 3, \"tab\"]],\n    template: function MdbTabsComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"ul\", 0);\n        ɵngcc0.ɵɵtemplate(1, MdbTabsComponent_li_1_Template, 4, 6, \"li\", 1);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(2, \"div\", 2);\n        ɵngcc0.ɵɵtemplate(3, MdbTabsComponent_ng_container_3_Template, 3, 5, \"ng-container\", 3);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction7(4, _c14, ctx.pills, !ctx.pills, ctx.fill, ctx.justified, ctx.vertical, ctx.vertical, ctx.vertical));\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.tabs);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngClass\", ɵngcc0.ɵɵpureFunction1(12, _c15, ctx.vertical));\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.tabs);\n      }\n    },\n    directives: function () {\n      return [ɵngcc1.NgClass, ɵngcc1.NgForOf, ɵngcc1.NgIf, ɵngcc5.CdkPortalOutlet, MdbTabPortalOutlet];\n    },\n    encapsulation: 2\n  });\n  return MdbTabsComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})(); // tslint:disable-next-line: directive-class-suffix\n\n\nlet MdbTabPortalOutlet = /*#__PURE__*/(() => {\n  class MdbTabPortalOutlet extends CdkPortalOutlet {\n    constructor(_cfr, _vcr, _document) {\n      super(_cfr, _vcr, _document);\n      this._destroy$ = new Subject();\n    }\n\n    ngOnInit() {\n      super.ngOnInit();\n\n      if ((this.tab.shouldAttach || this.tab.active) && !this.hasAttached()) {\n        this.attach(this.tab.content);\n      } else {\n        // tslint:disable-next-line: deprecation\n        this.tab.activeStateChange$.pipe(takeUntil(this._destroy$)).subscribe(isActive => {\n          if (isActive && !this.hasAttached()) {\n            this.attach(this.tab.content);\n          }\n        });\n      }\n    }\n\n    ngOnDestroy() {\n      this._destroy$.next();\n\n      this._destroy$.complete();\n\n      super.ngOnDestroy();\n    }\n\n  }\n\n  MdbTabPortalOutlet.ɵfac = function MdbTabPortalOutlet_Factory(t) {\n    return new (t || MdbTabPortalOutlet)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT));\n  };\n\n  MdbTabPortalOutlet.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MdbTabPortalOutlet,\n    selectors: [[\"\", \"mdbTabPortalOutlet\", \"\"]],\n    inputs: {\n      tab: \"tab\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return MdbTabPortalOutlet;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbTabsModule = /*#__PURE__*/(() => {\n  class MdbTabsModule {}\n\n  MdbTabsModule.ɵfac = function MdbTabsModule_Factory(t) {\n    return new (t || MdbTabsModule)();\n  };\n\n  MdbTabsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdbTabsModule\n  });\n  MdbTabsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, PortalModule]]\n  });\n  return MdbTabsModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbTabsModule, {\n    declarations: function () {\n      return [MdbTabComponent, MdbTabContentDirective, MdbTabTitleDirective, MdbTabPortalOutlet, MdbTabsComponent];\n    },\n    imports: function () {\n      return [CommonModule, PortalModule];\n    },\n    exports: function () {\n      return [MdbTabComponent, MdbTabContentDirective, MdbTabTitleDirective, MdbTabPortalOutlet, MdbTabsComponent];\n    }\n  });\n})();\n\nlet MdbCarouselItemComponent = /*#__PURE__*/(() => {\n  class MdbCarouselItemComponent {\n    constructor(_elementRef) {\n      this._elementRef = _elementRef;\n      this.interval = null;\n      this.carouselItem = true;\n      this.active = false;\n      this.next = false;\n      this.prev = false;\n      this.start = false;\n      this.end = false;\n    }\n\n    get host() {\n      return this._elementRef.nativeElement;\n    }\n\n    ngOnInit() {}\n\n  }\n\n  MdbCarouselItemComponent.ɵfac = function MdbCarouselItemComponent_Factory(t) {\n    return new (t || MdbCarouselItemComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MdbCarouselItemComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdbCarouselItemComponent,\n    selectors: [[\"mdb-carousel-item\"]],\n    hostVars: 12,\n    hostBindings: function MdbCarouselItemComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"carousel-item\", ctx.carouselItem)(\"active\", ctx.active)(\"carousel-item-next\", ctx.next)(\"carousel-item-prev\", ctx.prev)(\"carousel-item-start\", ctx.start)(\"carousel-item-end\", ctx.end);\n      }\n    },\n    inputs: {\n      interval: \"interval\"\n    },\n    ngContentSelectors: _c2,\n    decls: 1,\n    vars: 0,\n    template: function MdbCarouselItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return MdbCarouselItemComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar Direction = /*#__PURE__*/(() => {\n  (function (Direction) {\n    Direction[Direction[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    Direction[Direction[\"NEXT\"] = 1] = \"NEXT\";\n    Direction[Direction[\"PREV\"] = 2] = \"PREV\";\n  })(Direction || (Direction = {}));\n\n  return Direction;\n})();\nlet MdbCarouselComponent = /*#__PURE__*/(() => {\n  class MdbCarouselComponent {\n    constructor(_elementRef, _cdRef) {\n      this._elementRef = _elementRef;\n      this._cdRef = _cdRef;\n      this.animation = 'slide';\n      this.controls = false;\n      this.dark = false;\n      this.indicators = false;\n      this.ride = true;\n      this._interval = 5000;\n      this.keyboard = true;\n      this.pause = true;\n      this.wrap = true;\n      this.slide = new EventEmitter();\n      this.slideChange = new EventEmitter();\n      this._activeSlide = 0;\n      this._isPlaying = false;\n      this._isSliding = false;\n      this._destroy$ = new Subject();\n    }\n\n    get items() {\n      return this._items && this._items.toArray();\n    }\n\n    get interval() {\n      return this._interval;\n    }\n\n    set interval(value) {\n      this._interval = value;\n\n      if (this.items) {\n        this._restartInterval();\n      }\n    }\n\n    get activeSlide() {\n      return this._activeSlide;\n    }\n\n    set activeSlide(index) {\n      if (this.items.length && this._activeSlide !== index) {\n        this._activeSlide = index;\n\n        this._restartInterval();\n      }\n    }\n\n    onMouseEnter() {\n      if (this.pause && this._isPlaying) {\n        this.stop();\n      }\n    }\n\n    onMouseLeave() {\n      if (this.pause && !this._isPlaying) {\n        this.play();\n      }\n    }\n\n    ngAfterViewInit() {\n      Promise.resolve().then(() => {\n        this._setActiveSlide(this._activeSlide);\n\n        if (this.interval > 0 && this.ride) {\n          this.play();\n        }\n      });\n\n      if (this.keyboard) {\n        fromEvent(this._elementRef.nativeElement, 'keydown').pipe(takeUntil(this._destroy$)) // tslint:disable-next-line: deprecation\n        .subscribe(event => {\n          if (event.key === 'ArrowRight') {\n            this.next();\n          } else if (event.key === 'ArrowLeft') {\n            this.prev();\n          }\n        });\n      }\n    }\n\n    ngOnDestroy() {\n      this._destroy$.next();\n\n      this._destroy$.complete();\n    }\n\n    _setActiveSlide(index) {\n      const currentSlide = this.items[this._activeSlide];\n      currentSlide.active = false;\n      const newSlide = this.items[index];\n      newSlide.active = true;\n      this._activeSlide = index;\n    }\n\n    _restartInterval() {\n      this._resetInterval();\n\n      const activeElement = this.items[this.activeSlide];\n      const interval = activeElement.interval ? activeElement.interval : this.interval;\n\n      if (!isNaN(interval) && interval > 0) {\n        this._lastInterval = setInterval(() => {\n          const nInterval = +interval;\n\n          if (this._isPlaying && !isNaN(nInterval) && nInterval > 0) {\n            this.next();\n          } else {\n            this.stop();\n          }\n        }, interval);\n      }\n    }\n\n    _resetInterval() {\n      if (this._lastInterval) {\n        clearInterval(this._lastInterval);\n        this._lastInterval = null;\n      }\n    }\n\n    play() {\n      if (!this._isPlaying) {\n        this._isPlaying = true;\n\n        this._restartInterval();\n      }\n    }\n\n    stop() {\n      if (this._isPlaying) {\n        this._isPlaying = false;\n\n        this._resetInterval();\n      }\n    }\n\n    to(index) {\n      if (index > this.items.length - 1 || index < 0) {\n        return;\n      }\n\n      if (this.activeSlide === index) {\n        this.stop();\n        this.play();\n        return;\n      }\n\n      const direction = index > this.activeSlide ? Direction.NEXT : Direction.PREV;\n\n      this._animateSlides(direction, this.activeSlide, index);\n\n      this.activeSlide = index;\n\n      this._cdRef.markForCheck();\n    }\n\n    next() {\n      if (!this._isSliding) {\n        this._slide(Direction.NEXT);\n      }\n\n      this._cdRef.markForCheck();\n    }\n\n    prev() {\n      if (!this._isSliding) {\n        this._slide(Direction.PREV);\n      }\n\n      this._cdRef.markForCheck();\n    }\n\n    _slide(direction) {\n      const isFirst = this._activeSlide === 0;\n      const isLast = this._activeSlide === this.items.length - 1;\n\n      if (!this.wrap) {\n        if (direction === Direction.NEXT && isLast || direction === Direction.PREV && isFirst) {\n          return;\n        }\n      }\n\n      const newSlideIndex = this._getNewSlideIndex(direction);\n\n      this._animateSlides(direction, this.activeSlide, newSlideIndex);\n\n      this.activeSlide = newSlideIndex;\n      this.slide.emit();\n    }\n\n    _animateSlides(direction, currentIndex, nextIndex) {\n      const currentItem = this.items[currentIndex];\n      const nextItem = this.items[nextIndex];\n      const currentEl = currentItem.host;\n      const nextEl = nextItem.host;\n      this._isSliding = true;\n\n      if (this._isPlaying) {\n        this.stop();\n      }\n\n      if (direction === Direction.NEXT) {\n        nextItem.next = true;\n        setTimeout(() => {\n          this._reflow(nextEl);\n\n          currentItem.start = true;\n          nextItem.start = true;\n        }, 0);\n        const transitionDuration = 600;\n        fromEvent(currentEl, 'transitionend').pipe(take(1)) // tslint:disable-next-line: deprecation\n        .subscribe(() => {\n          nextItem.next = false;\n          nextItem.start = false;\n          nextItem.active = true;\n          currentItem.active = false;\n          currentItem.start = false;\n          currentItem.next = false;\n          this.slideChange.emit();\n          this._isSliding = false;\n        });\n\n        this._emulateTransitionEnd(currentEl, transitionDuration);\n      } else if (direction === Direction.PREV) {\n        nextItem.prev = true;\n        setTimeout(() => {\n          this._reflow(nextEl);\n\n          currentItem.end = true;\n          nextItem.end = true;\n        }, 0);\n        const transitionDuration = 600;\n        fromEvent(currentEl, 'transitionend').pipe(take(1)) // tslint:disable-next-line: deprecation\n        .subscribe(() => {\n          nextItem.prev = false;\n          nextItem.end = false;\n          nextItem.active = true;\n          currentItem.active = false;\n          currentItem.end = false;\n          currentItem.prev = false;\n          this.slideChange.emit();\n          this._isSliding = false;\n        });\n\n        this._emulateTransitionEnd(currentEl, transitionDuration);\n      }\n\n      if (!this._isPlaying && this.interval > 0) {\n        this.play();\n      }\n    }\n\n    _reflow(element) {\n      return element.offsetHeight;\n    }\n\n    _emulateTransitionEnd(element, duration) {\n      let eventEmitted = false;\n      const durationPadding = 5;\n      const emulatedDuration = duration + durationPadding;\n      fromEvent(element, 'transitionend').pipe(take(1)) // tslint:disable-next-line: deprecation\n      .subscribe(() => {\n        eventEmitted = true;\n      });\n      setTimeout(() => {\n        if (!eventEmitted) {\n          element.dispatchEvent(new Event('transitionend'));\n        }\n      }, emulatedDuration);\n    }\n\n    _getNewSlideIndex(direction) {\n      let newSlideIndex;\n\n      if (direction === Direction.NEXT) {\n        newSlideIndex = this._getNextSlideIndex();\n      }\n\n      if (direction === Direction.PREV) {\n        newSlideIndex = this._getPrevSlideIndex();\n      }\n\n      return newSlideIndex;\n    }\n\n    _getNextSlideIndex() {\n      const isLast = this._activeSlide === this.items.length - 1;\n\n      if (!isLast) {\n        return this._activeSlide + 1;\n      } else if (this.wrap && isLast) {\n        return 0;\n      } else {\n        return this._activeSlide;\n      }\n    }\n\n    _getPrevSlideIndex() {\n      const isFirst = this._activeSlide === 0;\n\n      if (!isFirst) {\n        return this._activeSlide - 1;\n      } else if (this.wrap && isFirst) {\n        return this.items.length - 1;\n      } else {\n        return this._activeSlide;\n      }\n    }\n\n  }\n\n  MdbCarouselComponent.ɵfac = function MdbCarouselComponent_Factory(t) {\n    return new (t || MdbCarouselComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef));\n  };\n\n  MdbCarouselComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MdbCarouselComponent,\n    selectors: [[\"mdb-carousel\"]],\n    contentQueries: function MdbCarouselComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MdbCarouselItemComponent, 4);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._items = _t);\n      }\n    },\n    hostBindings: function MdbCarouselComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"mouseenter\", function MdbCarouselComponent_mouseenter_HostBindingHandler() {\n          return ctx.onMouseEnter();\n        })(\"mouseleave\", function MdbCarouselComponent_mouseleave_HostBindingHandler() {\n          return ctx.onMouseLeave();\n        });\n      }\n    },\n    inputs: {\n      animation: \"animation\",\n      controls: \"controls\",\n      dark: \"dark\",\n      indicators: \"indicators\",\n      ride: \"ride\",\n      keyboard: \"keyboard\",\n      pause: \"pause\",\n      wrap: \"wrap\",\n      interval: \"interval\"\n    },\n    outputs: {\n      slide: \"slide\",\n      slideChange: \"slideChange\"\n    },\n    ngContentSelectors: _c2,\n    decls: 6,\n    vars: 7,\n    consts: [[1, \"carousel\", \"slide\"], [\"class\", \"carousel-indicators\", 4, \"ngIf\"], [1, \"carousel-inner\"], [\"class\", \"carousel-control-prev\", \"type\", \"button\", 3, \"click\", 4, \"ngIf\"], [\"class\", \"carousel-control-next\", \"type\", \"button\", 3, \"click\", 4, \"ngIf\"], [1, \"carousel-indicators\"], [\"type\", \"button\", 3, \"active\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"type\", \"button\", 3, \"click\"], [\"type\", \"button\", 1, \"carousel-control-prev\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"carousel-control-prev-icon\"], [1, \"visually-hidden\"], [\"type\", \"button\", 1, \"carousel-control-next\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"carousel-control-next-icon\"]],\n    template: function MdbCarouselComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵtemplate(1, MdbCarouselComponent_div_1_Template, 2, 1, \"div\", 1);\n        ɵngcc0.ɵɵelementStart(2, \"div\", 2);\n        ɵngcc0.ɵɵprojection(3);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(4, MdbCarouselComponent_button_4_Template, 4, 0, \"button\", 3);\n        ɵngcc0.ɵɵtemplate(5, MdbCarouselComponent_button_5_Template, 4, 0, \"button\", 4);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"carousel-fade\", ctx.animation === \"fade\")(\"carousel-dark\", ctx.dark);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.indicators);\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.controls);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.controls);\n      }\n    },\n    directives: [ɵngcc1.NgIf, ɵngcc1.NgForOf],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return MdbCarouselComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet MdbCarouselModule = /*#__PURE__*/(() => {\n  class MdbCarouselModule {}\n\n  MdbCarouselModule.ɵfac = function MdbCarouselModule_Factory(t) {\n    return new (t || MdbCarouselModule)();\n  };\n\n  MdbCarouselModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdbCarouselModule\n  });\n  MdbCarouselModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return MdbCarouselModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbCarouselModule, {\n    declarations: function () {\n      return [MdbCarouselComponent, MdbCarouselItemComponent];\n    },\n    imports: function () {\n      return [CommonModule];\n    },\n    exports: function () {\n      return [MdbCarouselComponent, MdbCarouselItemComponent];\n    }\n  });\n})();\n\nconst MDB_MODULES = [MdbCollapseModule, MdbCheckboxModule, MdbRadioModule, MdbTooltipModule, MdbPopoverModule, MdbFormsModule, MdbModalModule, MdbDropdownModule, MdbRippleModule, MdbValidationModule, MdbScrollspyModule, MdbRangeModule, MdbTabsModule, MdbCarouselModule];\nlet MdbModule = /*#__PURE__*/(() => {\n  class MdbModule {}\n\n  MdbModule.ɵfac = function MdbModule_Factory(t) {\n    return new (t || MdbModule)();\n  };\n\n  MdbModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MdbModule\n  });\n  MdbModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[MDB_MODULES], MdbCollapseModule, MdbCheckboxModule, MdbRadioModule, MdbTooltipModule, MdbPopoverModule, MdbFormsModule, MdbModalModule, MdbDropdownModule, MdbRippleModule, MdbValidationModule, MdbScrollspyModule, MdbRangeModule, MdbTabsModule, MdbCarouselModule]\n  });\n  return MdbModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MdbModule, {\n    imports: [MdbCollapseModule, MdbCheckboxModule, MdbRadioModule, MdbTooltipModule, MdbPopoverModule, MdbFormsModule, MdbModalModule, MdbDropdownModule, MdbRippleModule, MdbValidationModule, MdbScrollspyModule, MdbRangeModule, MdbTabsModule, MdbCarouselModule],\n    exports: [MdbCollapseModule, MdbCheckboxModule, MdbRadioModule, MdbTooltipModule, MdbPopoverModule, MdbFormsModule, MdbModalModule, MdbDropdownModule, MdbRippleModule, MdbValidationModule, MdbScrollspyModule, MdbRangeModule, MdbTabsModule, MdbCarouselModule]\n  });\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { MDB_CHECKBOX_VALUE_ACCESSOR, MDB_RADIO_GROUP_VALUE_ACCESSOR, MdbCarouselComponent, MdbCarouselItemComponent, MdbCarouselModule, MdbCheckboxChange, MdbCheckboxDirective, MdbCheckboxModule, MdbCollapseDirective, MdbCollapseModule, MdbDropdownDirective, MdbDropdownMenuDirective, MdbDropdownModule, MdbDropdownToggleDirective, MdbErrorDirective, MdbFormControlComponent, MdbFormsModule, MdbInputDirective, MdbLabelDirective, MdbModalConfig, MdbModalContainerComponent, MdbModalModule, MdbModalRef, MdbModalService, MdbModule, MdbPopoverDirective, MdbPopoverModule, MdbRadioDirective, MdbRadioGroupDirective, MdbRadioModule, MdbRangeComponent, MdbRangeModule, MdbRippleDirective, MdbRippleModule, MdbScrollspyDirective, MdbScrollspyElementDirective, MdbScrollspyLinkDirective, MdbScrollspyModule, MdbScrollspyService, MdbSuccessDirective, MdbTabComponent, MdbTabContentDirective, MdbTabTitleDirective, MdbTabsComponent, MdbTabsModule, MdbTooltipDirective, MdbTooltipModule, MdbValidateDirective, MdbValidationModule, MdbScrollspyWindowDirective as ɵa, RANGE_VALUE_ACCESOR as ɵb, MDB_TAB_CONTENT as ɵc, MDB_TAB_TITLE as ɵd, MdbTooltipComponent as ɵe, MdbPopoverComponent as ɵf, MdbAbstractFormControl as ɵg, MdbTabPortalOutlet as ɵh }; //# sourceMappingURL=mdb-angular-ui-kit.js.map","map":null,"metadata":{},"sourceType":"module"}